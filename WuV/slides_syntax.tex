\section{Language Layers}


\begin{frame}\frametitle{Layers of Language Design}
\begin{tabular}{l|ll}
Layer & Specified by & Implemented by \\\hline
Syntax & &\\
\tb Context-Free & grammar & parser \\
\tb Context-Sensitive & inference system & type checker \\
Semantics & \multicolumn{2}{l}{inference system, interpretation, or translation}\\
\hline
Pragmatics & human preferences & human judgment \\
\end{tabular}
\bigskip

KRP = syntax + semantics
\end{frame}

\begin{frame}\frametitle{Layered Processing}
Data is processed in phases
\begin{enumerate}
\item data representation format, e.g., string, JSON, XML, binary
\item parsed --- well-formed syntax tree
\item type-checked by traversal of the syntax tree --- well-typed syntax tree
\item computation by traversal of well-typed AST --- semantics
\end{enumerate}
\end{frame}

\begin{frame}\frametitle{Possible Errors}
\begin{tabular}{l|l}
Layer & Error \\\hline
CGFS & not derivable from grammar \\
CSS  & symbols not used as declared, other conditions\\
Sem. & ambiguous/undefined semantics \\
\hline
Pragmatics & not useful \\
\end{tabular}
\end{frame}


\begin{frame}\frametitle{Typical Errors by Layer}
In a programming language:

\begin{center}
\begin{tabular}{l|lll}
Layer & Expression & Issue & Explanation \\\hline
CFS & $1/$ & syntax error & argument missing\\
CSS & $1/"2"$ & typing error & wrong type\\
Sem. & $1/0$ & run-time error & undefined semantics \\
Pragm. & $1/1$ & code review & unnecessarily complex\\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Typical Errors by Layer}
In a logic:

\begin{center}
\begin{tabular}{l|lll}
Layer & Expression & Issue & Explanation \\\hline
CFS & $\forall x$ & not well-formed & body missing\\
CSS & $\forall x.P(y)$ & not well-typed & $y$ not declared\\
Sem. & the $x\in \N$ with $x<0$ & not well-defined & no such $x$ exists \\
Pragm. & $\exists x.x\neq x$ & not useful & no model exists\\
\end{tabular}
\end{center}
\end{frame}

\section{Context-Free Grammars}

\begin{frame}\frametitle{The Chomsky Hierarchy}
\begin{itemize}
\item CH-0, regular grammars: 
 \begin{itemize}
  \item equivalent to regular expressions and finite automata
  \item not used much as grammars
 \end{itemize}
\item CH-1, context-free grammars (CFGs) \lec{our focus}
\item CH-2, context-sensitive grammars
 \begin{itemize}
   \item important as languages, but awkward as grammars
   \item instead: type system determines subset of context-free language
 \end{itemize}
\item CH-3, unrestricted grammars
 \begin{itemize}
   \item Turing-complete, theoretically important
   \item not used much as grammars
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Definitions}
\begin{itemize}
\item An alphabet is a set of symbols.
\item A word is a list of symbols from the alphabet.
\item A production is pair of words.
 \begin{itemize}
 \item A production is written $lhs::=rhs$.
 \item Multiple productions for the same left-hand side are abbreviated $lhs::=rhs_1 \,|\,\ldots\,|\, rhs_n$.
 \item Right-hand side may also use regular expressions like $^*$ for repetition and $[]$ for optional parts.
 \end{itemize}
\item A CFG is a set of productions where $lhs$ is a single symbol.
 \begin{itemize}
 \item If there is a production $N::=rhs$, $N$ is called non-terminal, otherwise terminal.
 \item If a word contains non-terminal symbols, it is called non-terminal, otherwise terminal.
 \end{itemize}
\item A syntax tree is a tree with nodes are labeled with productions $N::=rhs$ where the non-terminals in rhs are exactly the lhs's of the children.
\item The word produced by a syntax tree is read off by exhaustively replacing every lhs with the respective rhs.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: Syntax of Arithmetic Language}
\begin{commgrammar}
\gcomment{Numbers}\\
\gprod{N}{0\bnfalt 1}{literals}\\
\galtprod{N+N}{sum}\\
\galtprod{N*N}{product}\\
\gcomment{Formulas}\\
\gprod{F}{N\doteq N}{equality}\\
\galtprod{N\leq N}{ordering by size}\\
\end{commgrammar}
\end{frame}

\section{Implementing CFGs via Inductive Data Types}

\begin{frame}\frametitle{Correspondence}
\begin{center}
\begin{tabular}{l|l}
CFG & IDT \\
\hline
non-terminal & type \\
production & constructor \\
non-terminal on left of production & return type of constructor \\
non-terminals on right of production & arguments types of constructor \\
terminals on right of production & notation of constructor\\
words derived from non-terminal $N$ & expressions of type $N$
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Classes of Languages}
Functional languages:
\begin{itemize}
\item pure: ML, Haskell
\item with OO: F\#, Scala
\end{itemize}
\lec{inductive types are primitive}

OO-languages:
\begin{itemize}
\item C\#, Java, C++
\end{itemize}
\lec{inductive types simulated via classes}

Untyped languages:
\begin{itemize}
\item Python, Javascript
\end{itemize}
\lec{inductive types simulated ad hoc}
\end{frame}

\begin{frame}\frametitle{Implementing the Example}
Done interactively. See also notes.
\end{frame}


\begin{frame}\frametitle{Exercise 3}
Individually, using any programming language, implement the AST for the BOL language.
Allow for integers and strings as basic types.

Implement a type-checker for BOL.
BOL is untyped, and not much type-checking is needed.
The main check needed is that all property assertion use values according to the property type.
\end{frame}
