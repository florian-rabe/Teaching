\section{Language Layers}

\begin{frame}\frametitle{Layers of Language Design}
\begin{tabular}{l|lll|l}
Layer & Specified by & Implemented by & Possible error \\\hline
Context-Free Syntax & grammar & parser & not derivable from grammar & \\
Context-Sensitive Syntax & inference system & type checker & symbols not used as declared & KRP \\
Semantics & \multicolumn{2}{l}{inference system, interpretation, or translation} & undefined semantics & \\
\hline
Pragmatics & human preferences & human judgment & not useful & not KRP \\
\end{tabular}
\end{frame}

\begin{frame}\frametitle{Layered Processing}
Data is processed in phases
\begin{enumerate}
\item data representation format, e.g., string, JSON, XML, binary
\item parsed --- well-formed syntax tree
\item type-checked by traversal of the syntax tree --- well-typed syntax tree
\item computation by traversal of well-typed AST --- semantics
\end{enumerate}
\end{frame}

\begin{frame}\frametitle{Typical Errors by Layer}
In a programming language:

\begin{center}
\begin{tabular}{l|lll}
Layer & Expression & Issue & Explanation \\\hline
Context-Free Syntax & $1/$ & syntax error & argument missing\\
Context-Sensitive Syntax & $1/"2"$ & typing error & argument has wrong type\\
Semantics & $1/0$ & run-time error & undefined semantics \\
Pragmatics & $1/1$ & code review comment & unnecessarily complex expression \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Typical Errors by Layer}
In a logic:

\begin{center}
\begin{tabular}{l|lll}
Layer & Expression & Issue & Explanation \\\hline
Context-Free Syntax & $\forall x$ & not well-formed & body missing\\
Context-Sensitive Syntax & $\forall x.P(y)$ & not well-typed & $y$ not declared\\
Semantics & the $x\in \N$ such that $x<0$ & not well-defined & no such $x$ exists \\
Pragmatics & $\exists x.x\neq x$ & inconsistent & no model exists\\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{The Chomsky Hierarchy}
\begin{itemize}
\item CH-0, regular grammars: 
 \begin{itemize}
  \item equivalent to regular expressions and finite automata
  \item not used much as grammars
 \end{itemize}
\item CH-1, context-free grammars (CFGs) \lec{our focus}
\item CH-2, context-sensitive grammars
 \begin{itemize}
   \item important as languages, but awkward as grammars
   \item instead: type system determines subset of context-free language
 \end{itemize}
\item CH-3, unrestricted grammars
 \begin{itemize}
   \item Turing-complete, theoretically important
   \item not used much as grammars
 \end{itemize}
\end{itemize}
\end{frame}

\section{Context-Free Grammars and Inductive Data Types}

\begin{frame}\frametitle{Correspondence}
\begin{center}
\begin{tabular}{l|l}
CFG & IDT \\
\hline
non-terminal & type \\
production & constructor \\
non-terminal on left of production & return type of constructor \\
non-terminals on right of production & arguments types of constructor \\
terminals on right of production & notation of constructor\\
words derived from non-terminal $N$ & expressions of type $N$
\end{tabular}
\end{center}
\end{frame}

\section{Inductive Data Types in Programming Languages}

\begin{frame}\frametitle{Classes of Languages}
Functional languages:
\begin{itemize}
\item pure: ML, Haskell
\item with OO: F\#, Scala
\end{itemize}
\lec{inductive types are primitive}

OO-languages:
\begin{itemize}
\item C\#, Java, C++
\end{itemize}
\lec{inductive types simulated via classes}

Untyped languages:
\begin{itemize}
\item Python, Javascript
\end{itemize}
\lec{inductive types simulated ad hoc}
\end{frame}

\begin{frame}\frametitle{Exercise 3}
Individually, using any programming languaeg, implement the AST for the BOL language.
Allow for integers and strings as basic types.

Implement a type-checker for BOL.
BOL is untyped, and not much type-checking is needed.
The main check needed is that all property assertion use values according to the property type.
\end{frame}
