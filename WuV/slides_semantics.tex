\section{Kinds of Semantics}

\begin{frame}\frametitle{Recall}
Recall:

\begin{center}
\begin{tabular}{l|l}
Syntax & Data \\
\hline
Semantics & Knowledge
\end{tabular}
\end{center}

Representing
\begin{itemize}
\item syntax = formal language
\begin{itemize}
\item grammar  \glec{context-free part}
\item type system \glec{context-sensitive well-formedness}
\end{itemize}
\item data = words in the syntax
\begin{itemize}
\item set of vocabularies
\item set of typed expressions for each vocabulary
\end{itemize}
\item semantics = \alert{???}
\item knowledge = emergent property of having well-formed words with semantics
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Relative Semantics by Translation}
Components:
\begin{itemize}
\item Two syntaxes
\begin{itemize}
\item object-language $l$ \glec{e.g., BOL}
\item meta-language $L$ \glec{e.g., SFOL, Scala, SQL, English}
\end{itemize}
\item Semantics of $L$ assumed fixed
 \glec{captures what we already know}
\item Semantics of $l$ by translation into $L$
\end{itemize}
\lec{semantics of $l$ \emph{relative} to to existing semantics of $L$}

Problem: just kicking the can?
\end{frame}

\begin{frame}\frametitle{Discussion of Semantics by Translation}
\begin{blockitems}{Advantages}
\item a few meta-languages yield semantics for many languages
\item easy to develop new languages
\item good connection between syntax and semantics via compositionality, substitution theorem
\end{blockitems}

\begin{blockitems}{Disadvantages}
\item does not solve the problem once and for all
\item impractical without implementation of semantics of meta-language
\item meta-languages typically much more expressive than needed for object-languages
\item translations can be difficult, error-prone
\end{blockitems}

Also needed: absolute semantics
\end{frame}

\begin{frame}\frametitle{Absolute vs. Relative Semantics}
Absolute = self-contained, no use of meta-language $L$

\begin{blockitems}{Get off the ground}
 \item semantics for a few important meta-languages
  \glec{e.g., FOL, assembly language, set theory}
 \item relative semantics for all other languages, e.g.,
  \begin{itemize}
  \item model theory: logic $\to$ set theory
  \item compilation: Scala $\to$ JVM $\to$ assembly
  \end{itemize}
\end{blockitems}

\begin{blockitems}{Redundant semantics}
 \item common to give
 \begin{itemize}
  \item relative and absolute semantics for same syntax
  \item multiple relative semantics
   \glec{translations to different aspects}
  \item sometimes even maybe multiple absolute ones
 \end{itemize}
 \item Allows understanding syntax from multiple perspectives
 \item Allows cross-checking \glec{show equivalence of two semantics}
\end{blockitems}
\end{frame}


\begin{frame}\frametitle{Example: Recall Syntax of Arithmetic Language}
Syntax: represented as formal grammar

\begin{commgrammar}
\gcomment{Numbers}\\
\gprod{N}{0\bnfalt 1}{literals}\\
\galtprod{N+N}{sum}\\
\galtprod{N*N}{product}\\
\gcomment{Formulas}\\
\gprod{F}{N\doteq N}{equality}\\
\galtprod{N\leq N}{ordering by size}\\
\end{commgrammar}

Implementation as inductive data type
\end{frame}

\begin{frame}\frametitle{Example: Absolute Semantics}
\begin{blockitems}{Represented as judgments defined by sets of rules}
\item unclear what judgments to use
\item here: computation $\der N \rewrites N$ and truth $\der F$
\end{blockitems}

For numbers $n$: Rules to normalize numbers into values
\[\rul{}{\der N+0\rewrites N} \tb \rul{}{\der N*0\rewrites 0}\tb \rul{}{\der N*1\rewrites N}\]
\[\rul{}{\der N*(R+S)\rewrites N*R+N*S}\]
and their commutative variants as well as
\[\rul{}{\der L+(M+N)\rewrites (L+M)+N}\]


For formulas $f$: rules to determine true formulas
\[\rul{}{\der N\doteq N} \tb \rul{}{\der 0\leq N} \tb \rul{\der L\leq M}{\der L+N\leq M+N}\]
\end{frame}

\begin{frame}\frametitle{Example: Absolute Semantics (2)}
Checking if an absolute semantics works as intended is hard.

Here: number rules allow
\begin{enumerate}
\item eliminating all cases where arguments of $*$ are $0$, $1$, or $+$; thus, no more $*$
\item eliminating all cases where arguments of $+$ are $0$
\item shift brackets of nested $+$ to the left
\item left: $0$ or $(\ldots(1+1)\ldots+1)$ --- isomorphic to natural numbers
\end{enumerate}
formula rules allow
\begin{enumerate}
\item concluding equality if identical normal forms
\item reducing $M+1\leq N+1$ to $M\leq N$, repeat until $0\leq N$
\end{enumerate}
\end{frame}


\begin{frame}\frametitle{Example: Relative Semantics}
Semantics: represented as translation into known language
\medskip

Problem: Need to choose a known language first\\
Here: unary numbers represented as strings

Built-in data (strings and booleans):
\begin{commgrammar}
%\gcomment{Strings}\\
\gprod{S}{""}{empty}\\
\galtprod{(\texttt{Unicode)}}{character sequence}\\
%\gcomment{Booleans}\\
\gprod{B}{\cn{true}}{truth}\\
\galtprod{\cn{false}}{falsity}\\
\end{commgrammar}

Built-in operations to work on the data:
\begin{itemize}
\item concatenation of strings $S\bbc \cn{conc}(S,S)$
\item replacing all occurrences of $c$ in $S_1$ with $S_2$ $S\bbc \cn{replace}(S_1,c,S_2)$
\item equality test: $B\bbc S_1==S_2$
\item prefix test: $B\bbc \cn{startsWith}(S_1,S_2)$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: Relative Semantics}
\begin{blockitems}{Represented as function from syntax to semantics}
\item mutually recursive, inductive functions for each non-terminal symbol
\item compositional: recursive call on immediate subterms of argument
\end{blockitems}

For numbers $n$: semantics $\sem{n}$ is a string
\begin{itemize}
\item $\sem{0}=""$
\item $\sem{1}="|"$
\item $\sem{m+n}=\cn{conc}(\sem{m},\sem{n})$
\item $\sem{m*n}=\cn{replace}(\sem{m},"|",\sem{n})$
\end{itemize}
\medskip

For formulas $f$: semantics $\sem{f}$ is a boolean
\begin{itemize}
\item $\sem{m\doteq n}=\sem{m}==\sem{n}$
\item $\sem{m\leq n}=\cn{startsWith}(\sem{n},\sem{m})$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: Equivalence of Semantics}
\begin{blockitems}{For formulas}
\item if $\der F$, then $\sem{F}=true$ 
 \glec{usually called \emph{soundness}}
\item if $\sem{F}=true$, then $\der F$
 \glec{usually called \emph{completeness}}
\end{blockitems}

\begin{blockitems}{For numbers}
\item $\der N\rewrites 0$ iff $\sem{N}=""$
\item $\der N\rewrites (\ldots(1+1)\ldots+1)$ iff $\sem{N}="|\ldots|"$
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{No Perfect Model for Absolute Semantics}
\begin{itemize}
\item Machine-actionable requires reduction to finite set of rules
 \lec{whatever a rule is}
\item Does not work for most domains
 \begin{itemize}
 \item practical argument: any practically interesting system has too many rules
  \glec{cf. physics, e.g., three-body problem already chaotic}
 \item theoretical argument: no language can fully model itself
  \glec{cf. G\"odel's incompleteness theorems}
 \end{itemize}
\item Imperfect representation of intended semantics required
\lec{focus on some \emph{aspect}}
\end{itemize}

Big question: what aspects to focus on?
\end{frame}

\begin{frame}\frametitle{Querying as a Guide}
\begin{blockitems}{Idea}
\item Very difficult to choose aspects for absolute semantics
\item Turn problem around
 \begin{itemize}
 \item ask what the practical purpose of the semantics could be
 \item then choose aspects that allow realizing that purpose
 \end{itemize}
\end{blockitems}

Meta-remark: We do relative semantics first even though absolute semantics conceptually comes first.

\begin{blockitems}{Querying as the Purpose}
\item Before: identified different kinds of querying
 \lec{focussing on different aspects of knowledge}
\item Now: each induces a kind of absolute semantics
\end{blockitems}
\end{frame}


\section{Relative Semantics for BOL}

\begin{frame}\frametitle{Semantics of BOL}
\begin{center}
\begin{tabular}{lll}
Aspect & kind of semantic language & semantic language\\
\hline 
deduction & logic & SFOL \\
concretization & database language & SQL \\
computation & programming language & Scala \\
narration & natural language & English \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Deductive Semantics of BOL in SFOL}
We discuss
\begin{itemize}
\item the grammar of SFOL
\item context-sensitive languages with variable binding (of which SFOL is an example)
\item an implementation of SFOL in Scala
\item the translation from BOL to SFOL
\item compositionality of the translation
\item the issue of
 \begin{itemize}
 \item non-compositionality
 \item the need for a semantic prefix
 \end{itemize}
\end{itemize}
see details in the lecture notes
\end{frame}

\begin{frame}\frametitle{Exercise 7}
Extend your implementation of BOL with implementations of SFOL and the translation from BOL to SFOL.
\end{frame}

\begin{frame}[fragile]\frametitle{Exercise 8}
Use an existing absolute SFOL semantics for BOL.
Concretely this semantics is given in the form of theorem provers like Vampire, E, or Spass.
These use TPTP as the input format.

So extend your implementation of SFOL with a printer to TPTP format.
Compose your translation with that printer to translate your example ontology and an example query (a formula to be proved) to a theorem prover.

See \url{https://www.tptp.org/} for the TPTP resources, including the grammar and a web interface to theorem provers.
The basic syntax is
\begin{lstlisting}
fof(id, type, name : the type).
fof(id, axiom, the formula).
fof(id, conjecture, the formula).
\end{lstlisting}
where formulas are formed using \lstinline|![X:TYPE]:F|, \lstinline|?[X:TYPE]:F|, \lstinline|F&F|, \lstinline!F|F!, \lstinline|F=>F|, \lstinline|~F|
\end{frame}

\begin{frame}\frametitle{General Definition}
A semantics by translation consists of
\begin{itemize}
 \item syntax: a formal system $l$
 \item semantic language: a formal system $L$
  \glec{different or same aspect as $l$}
 \item semantic prefix: a vocabulary $P$ in $L$
  \glec{formalizes fundamentals that are needed to represent $l$-objects}
 \item interpretation: translates every $l$-vocabulary $T$ to an $L$-vocabulary $P,\sem{T}$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Common Principles}
Properties shared by all semantics by translation
\lec{not part of formal definition, but best practices}
\begin{itemize}
 \item $l$-declaration translated to $L$-declaration for the same name
 \item vocabularies translated declaration-wise
 \item one inductive function for every kind of complex $l$-expression
  \begin{itemize}
   \item individuals, concepts, relations, properties, formulas
   \item maps $l$-expressions to $L$-expressions
  \end{itemize}
 \item atomic cases (base cases): $l$-identifier translated to $L$-identifier of the same name
  \glec{or something very similar}
 \item complex cases (step cases): compositional
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Translation vs. Embedding}
\begin{blockitems}{Translation}
\item as above, $l$ and $L$ are at the same level
\item $l$-declarations represented as $L$-declarations
\glec{also called shallow embedding}
\end{blockitems}

\begin{blockitems}{Embedding}
\item $L$ is used as meta-language to represent $l$
 \glec{e.g., $L$ is programming language to implement $l$}
\item $l$-declarations represented as $L$-objects using an inductive type
\glec{also called deep embedding}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Compositionality}
Case for operator $*$ in translation function compositional iff \\
interpretation of $*(e_1,\ldots,e_n)$ only depends on on the interpretation of the $e_i$

\[\sem{*(e_1,\ldots,e_n)}=\sem{*}(\sem{e_1},\ldots,\sem{e_n})\]
for some function $\sem{*}$
\bigskip

Example: $;$-operator of BOL in translation to FOL
\begin{itemize}
 \item translation: $\sem{R_1 ; R_2}= \exists m:\iota.\sem{R_1}(x,m)\wedge \sem{R_2}(m,y)$
 \item special case of the above via
  \begin{itemize}
  \item $*=;$
  \item $n=2$
  \item $\sem{;}=(p_1,p_2)\mapsto \exists m:\iota.p_1(x,m)\wedge p_2(m,y)$
  \end{itemize}
 \item Indeed, we have $\sem{R_1;R_2}=\sem{;}(\sem{R_1},\sem{R_2})$
\end{itemize}
\end{frame}


\begin{frame}\frametitle{Compositionality (2)}
Translation compositional iff
\begin{itemize}
\item one translation function for each non-terminal
 \glec{all written $\sem{-}$}
\item each defined by one induction on syntax
 \glec{i.e., one case for production}
 \glec{mutually recursive}
\item all cases compositional
\end{itemize}
\bigskip

Substitution theorem: a compositional translation satisfies
\[\sem{E(e_1,\ldots,e_n)}=\sem{E}(\sem{e_1},\ldots,\sem{e_n})\]
for
\begin{itemize}
\item every expression $E(N_1,\ldots,N_n)$ with non-terminals $N_i$
\item some function $\sem{E}$ that only depends on $E$
\end{itemize}
\end{frame}


\begin{frame}\frametitle{Compositionality (3)}
\[\sem{E(e_1,\ldots,e_n)}=\sem{E}(\sem{e_1},\ldots,\sem{e_n})\]
for every expression $E(N_1,\ldots,N_n)$ with non-terminals $N_i$
\bigskip

Now think of
\begin{itemize}
\item variable $x_i$ of type $N_i$ instead of non-terminal $N_i$
\item $E(x_1,\ldots,x_n)$ as expression with free variables $x_i$ of type $N_i$
\item expressions $e$ derived from $N$ as expressions of type $N$
\item $E(e_1,\ldots,e_n)$ as result of substituting $e_i$ for $x_i$
\item $\sem{E}(x_1,\ldots,x_n)$ as (semantic) expression with free variables $x_i$
\end{itemize}

Then both sides of equations act on $E(x_1,\ldots,x_n)$:
\begin{itemize}
\item left side yields $\sem{E(e_1,\ldots,e_n)}$ by
\begin{itemize}
\item first substitution $e_i$ for $x_i$
\item then semantics $\sem{-}$ of the whole
\end{itemize}
\item right side yields $\sem{E}(\sem{e_1},\ldots,\sem{e_n})$ by
\begin{itemize}
\item first semantics $\sem{-}$ of all parts
\item then substitution $\sem{e_i}$ for $x_i$
\end{itemize}
\end{itemize}
\lec{semantics commutes with substitution}
\end{frame}

\begin{frame}\frametitle{Non-Compositionality}
\begin{blockitems}{Examples}
 \item deduction: cut elimination, translation from natural deduction to Hilbert calculus
 \item computation: optimizing compiler, e.g., loop unrolling
 \item concretization: query optimization, e.g., turning a WHERE of a join into a join of WHEREs,
 \item narration: ambiguous words are translated based on context
\end{blockitems}

\begin{blockitems}{Typical sources}
 \item subcases in a case of translation function
  \begin{itemize}
  \item based on inspecting the arguments, e.g., subinduction
  \item based on context
  \end{itemize}
 \item custom-built semantic prefix
\end{blockitems}
\end{frame}

\section{Absolute Semantics for BOL}

\begin{frame}\frametitle{Judgments}
Typing:  \[\Gamma\vdash^{BOL}_V e:E\]
Deduction: \[\Gamma\vdash^{BOL}_V F\]

Propositions $\prop$:
\begin{itemize}
\item $C\sqsubseteq D$, $C\Equiv D$
\item all three kinds of assertions
\end{itemize}

Notation:
\begin{itemize}
\item We drop the superscript $^{BOL}$ everywhere.
\item We drop the subscript $_V$ unless we need to use $V$.
\item We drop the context $\Gamma$ unless we need to use/change $\Gamma$.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Typing}
Trivial intrinsic typing (Church) $\vdash e:^{int} E$
\begin{itemize}
\item $E$ is a non-terminal
\item $e$ an expression derived from $E$
\end{itemize}
\medskip

Refined by extrinsic typing (Curry) $\vdash e :^{ext} E$
\begin{itemize}
\item $e$ is an individual, i.e., $\vdash e :^{int} I$
\item $E$ is a concept, i.e., $\vdash E :^{int} C$
 \glec{where $I$ and $C$ are the non-terminals from the grammar}
\item $e$ has concept $E$, i.e., $\vdash e \isa E$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Propositions as Types}
Say also $\vdash p:f$ for proofs $p$ of proposition $f$
\lec{in particular: $x:f$ in contexts to make local assumptions}
\medskip

Notation:
\[\Gamma,\; f \tb\text{instead of} \tb \Gamma,\;p:f\]
\glec{sufficient if we only state the rules, not build proofs}
\end{frame}

\begin{frame}\frametitle{Lookup Rules}
The main rules that need to access the vocabulary:
\[\rul{f\minn V}{\vdash_V f}\]
\glec{for assertions or axioms f}
\medskip

Assumptions in the context are looked up accordingly:
\[\rul{x:f\minn \Gamma}{\Gamma\vdash f}\]
\end{frame}

\begin{frame}\frametitle{Rules for Subsumption and Equality}
Subsumption is an order with respect to equality:
\[\rul{}{\vdash c\sqsubseteq c}\]

\[\rul{\vdash c\sqsubseteq d \tb \vdash d\sqsubseteq e}{\vdash c\sqsubseteq e}\]

\[\rul{\vdash c\sqsubseteq d \tb \vdash d\sqsubseteq c}{\vdash c\Equiv d}\]

Equal concepts can be substituted for each other:
\[\rul{\vdash c\Equiv d\tb x:C\vdash f(x):\prop \tb \vdash f(c)}{\vdash f(d)}\]

\glec{This completely defines equality.}
\end{frame}

\begin{frame}\frametitle{Rules relating Instancehood and Subsumption}
\[\rul{\vdash i\isa c \tb \vdash c\sqsubseteq d}{\vdash i\isa d}\]
Read:
\begin{itemize}
\item if
 \begin{itemize}
 \item $i\isa c$
 \item $c\sqsubseteq d$
 \end{itemize}
\item then $i\isa d$
\end{itemize}

\[\rul{x:I,\,x\isa c\vdash x\isa d}{\vdash c\sqsubseteq d}\]
Read:
\begin{itemize}
\item if
 \begin{itemize}
 \item assuming an individual $x$ and $x\isa c$, then $x\isa d$
 \end{itemize}
\item then $c\sqsubseteq d$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Induction}
Consider from before
\[\rul{x:I,\,x\isa c\vdash x\isa d}{\vdash c\sqsubseteq d}\]

Question: Do we allow proving the hypothesis by checking for each individual $x$?
 \lec{induction}
\begin{itemize}
\item<2-> Open world: no
\item<3-> Closed world: yes
 \[\rul{\Gamma[x=i]\vdash f[x=i] \;\text{ for every individual } i}{\Gamma, x:I\vdash f(x)}\]
 \glec{effectively applicable if only finitely many individuals}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Rules for Union and Intersection of Concepts}
Union as the least upper bound:
\[\rul{}{\vdash c\sqsubseteq c\sqcup d} \tb\tb \rul{}{\vdash d\sqsubseteq c\sqcup d }\]
\[\rul{\vdash c\sqsubseteq h \tb \vdash d\sqsubseteq h}{\vdash c\sqcup d \sqsubseteq h}\]
\medskip

Dually, intersection as the greatest lower bound:
\[\rul{}{\vdash c\sqcap d\sqsubseteq c} \tb\tb \rul{}{\vdash c\sqcap d\sqsubseteq d}\]
\[\rul{\vdash h\sqsubseteq c \tb \vdash h\sqsubseteq d}{\vdash h \sqsubseteq c\sqcap d}\]
\end{frame}

\begin{frame}\frametitle{Rules for Existential and Universal}
Easy rules:
\begin{itemize}
\item Existential
\[\rul{\vdash i\,r\,j \tb \vdash j\isa c}{\vdash i \isa \exists r.c }\]
\item Universal
\[\rul{\vdash i \isa \forall r.c \tb \vdash i\,r\,j}{\vdash j\isa c}\]
\end{itemize}

Other directions are trickier:

\begin{itemize}
\item Existential
\[\rul{\vdash i \isa \exists r.c \tb j:I,\;i\,r\,j,\;j\isa c\vdash f}{\vdash f}\]
\item Universal
\[\rul{j:I,\; i\,r\,j\vdash j\isa c}{\vdash i\isa\forall r.c}\]
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Selected Rules for Relations}
Inverse:
\[\rul{\vdash i \,r\,j}{\vdash j\,r^{-1}\,i}\]

Composition:
\[\rul{\vdash i \,r\,j \tb \vdash j\,s\,k}{\vdash i\,(r;s)\,k}\]

Transitive closure:
\[\rul{}{\vdash i \,r^*\,i} \tb \rul{\vdash i\,r\,j \tb \vdash j\,r^* k}{\vdash i\,r^* k}\]

Identity at concept $c$:
\[\rul{\vdash i \isa c}{\vdash i\,\Delta_c i}\]
\end{frame}

%\begin{frame}\frametitle{Problems}
%Next
%\begin{itemize}
%\item four kinds of absolute semantics
% \lec{one per aspect}
%\item Each motivated by one kind of querying
%\item Each defines the aspect
% \glec{e.g., a logic is a language with deductive semantics}
%\end{itemize}
%
%Relation to previous slides
%\begin{itemize}
% \item before: querying via relative semantics
% \item just the special case where target language has corresponding absolute semantics
%  \glec{e.g., deductive querying possible given deductive semantics}
%  \glec{no matter if relative or absolute}
% \item conceptually, absolute semantics comes first, but easier to understand after querying
% \item discussed problems apply to absolute semantics accordingly
%\end{itemize}
%\end{frame}

\part{Formal Semantics}

\section{Formal Systems}

\begin{frame}\frametitle{Typical Structure of a Formal System}
Vocabularies
\begin{itemize}
\item lists of declarations
\end{itemize}

Declarations
\begin{itemize}
\item named
\item at least one for each expression kind
\item may contain other expressions \glec{e.g., type, definition}
\item may contain nested declarations \glec{e.g., fields in an ADT}
\end{itemize}

Expressions
\begin{itemize}
\item inductive data type
\item relative to vocabulary \glec{names occur as base cases}
\item formulas as special case
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: Vocabularies and Expressions}
\begin{center}
\footnotesize
\begin{tabular}{l|ll}
Aspect & vocabulary $\Theta$ & expression kinds \\
\hline
Ontologization  & ontology & individual, concept, relation, property, formula \\
Concretization & database schema & cell, row, table, formula \\
Computation & program & term, type, object, class, \ldots \\
Logic & signature, theory & term, type, formula, \ldots \\
Narration & dictionary & phrases, sentences, texts \\
\end{tabular}
\end{center}
\end{frame}

%\begin{frame}\frametitle{Examples}
%See notes made during the lecture for examples
%\end{frame}

\begin{frame}\frametitle{Components and Well-Formedness}
\begin{blockitems}{Components of formal system $l$}
 \item context-free syntax
 \item distinguished non-terminal symbol $\ThySym$ \glec{words called \textbf{vocabularies}}
 \item some distinguished non-terminal symbols \glec{words called \textbf{expressions}}
 \item unary predicate $\wft{V}$ on vocabularies $V$ \glec{well-formed vocabulary $V$}
 \item unary predicates $\wff{V}{e}$ \glec{well-formed expressions $e$}
\end{blockitems}

\begin{blockitems}{Intuition}
\item context-\emph{free} syntax generates more than needed
\item context-\emph{sensitive} well-formedness defines the exact subset
\end{blockitems}

Question: How do we define the well-formedness predicates?
\lec{use an inference system with context-sensitive rules}
\end{frame}

\begin{frame}\frametitle{Inference System}
\begin{blockitems}{Define well-formedness via type system}
\item contexts $\Gamma$ of the form $x_1:E_1,\ldots,x_n:E_n$ for expressions $E_i$
\item a set of judgments including
 \begin{itemize}
  \item a judgment $\vdash^l V$ on vocabularies $V$
  \glec{$\wft{V} \;\miff\; \vdash^l_V$}
  \item a judgment $\Gamma\vdash^l_V e:E$ between expressions $e,E$
  \glec{$\wff{V}{e}\;\miff\; \vdash^l_V e:E \mforsome E$} 
 \end{itemize}
\item a set of rules for the judgments, each one of the form
\[\rul{J_1 \tb \ldots \tb J_n}{J}\]
where the $J$'s are judgments
\end{blockitems}
\glec{conventions: leave out superscript $l$, subscript $V$ if clear}
\glec{leave out $\Gamma$ if empty}
\end{frame}

\begin{frame}\frametitle{Terminology}
For an inference system, we define
\begin{itemize}
\item derivation: tree of judgments such that for every node $J$ with children $J_1,\ldots,J_n$, there is a rule
\[\rul{J_1 \tb \ldots \tb J_n}{J}\]
\item derivation of $J$: a derivation with root $J$
\item $J$ holds: there is a derivation of $J$
\end{itemize}
\[\Voc^l = \{V\,|\,\vdash^l V\}\]
\[\Exp^l_V(E) = \{e\,|\,\vdash^l_V e:E\}\]
\[\Exp^l_V = \bigcup_E \Exp^l_V(E)\]
\end{frame}

\begin{frame}\frametitle{Special Cases}
\begin{blockitems}{A formal system with propositions}
\item additionally has a distinguished expression $\prop$
\item define $F$ is proposition if $\vdash_V F:\prop$
\end{blockitems}

\begin{blockitems}{A formal system with equality}
\item additionally has a distinguished proposition $e_1\doteq_E e_2$ whenever $\vdash e_i:E$
\end{blockitems}
\glec{in the sequel: fix $l$ as above}
\end{frame}

\section{Deductive Semantics}

\begin{frame}\frametitle{Deductive Semantics}
\begin{blockitems}{Definition}
\item a system that determines which propositions are theorems
\item for every $V$, a subset $\Thm^l_V\sq \Exp^l_V(\prop)$ of theorems
 \glec{write $\vdash^l_V F$ for $F\in\Thm^l_V$}
\end{blockitems}

\begin{blockitems}{Terminology}
\item Logic: language plus deductive semantics
\item Calculus: set of rules defining absolute deductive semantics
\item Theorem prover: implementation of deductive semantics
\item Decision procedure: special case of theorem prover when decidable
\end{blockitems}

\begin{blockitems}{Examples}
\item Natural deduction for first-order logic
\item Axiomatic set theory for (most of) mathematics
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Redundant Deductive Semantics}
\begin{blockitems}{Multiple deductive semantics}
\item Proof theory: absolute
\item Model theory: relative via translation to set theory $L$
 \glec{write $\models F$ for $\vdash_L \truelift\sem{F}$}
\item Logic translation: relative via translation into standard logics, e.g., SFOL
\end{blockitems}

\begin{blockitems}{Equivalence Theorems}
\item Soundness: $\vdash F$ implies $\models F$
\item Completeness: $\models F$ implies $\vdash F$
\glec{accordingly for other translations}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Relationship to Typing}
Define deductive semantics as a special case of typing
\begin{itemize}
\item propositions as types
\item proofs as expressions
\item extend grammar so that there are expressions for proofs
\item add typing rules such that $\vdash P:F$ captures the statement ``$P$ is proof of $F$''
\item define: $\vdash F$ iff there is $P$ such that $\vdash P:F$
\end{itemize}
\lec{often called Curry-Howard representation}
\end{frame}

\section{Computational Semantics}

\begin{frame}\frametitle{Computational Semantics}
\begin{blockitems}{Definition}
\item determines how expressions evaluate to values
\item for every $V$, a function $\Eval^l_V:\Exp^l_V\to\Exp^l_V$
\glec{write $\vdash^l_V e\rewrites e'$ for $e'=\Eval^l_V(e)$}
\end{blockitems}

\begin{blockitems}{Terminology}
\item Programming language: languages plus computational semantics
\item Operational semantics: rules defining computational semantics
\item Interpreter: implementation of absolute semantics
\item Compiler: implementation of relative semantics
\end{blockitems}

\begin{blockitems}{Examples}
\item Any interpreted language \glec{Python, bash, \ldots}
\item Machine language \glec{interpretation rules built into microchips}
\end{blockitems}
\end{frame}

\begin{frame}{Caveat}
Evaluation $\vdash^l_V e\rewrites e'$ insufficient in general
\glec{special case of interpreter when evaluation pure and terminating}

Actual programming languages more complex
\begin{itemize}
\item IO channels
\item Object creation/destruction
\item Mutable variables
\item Non-termination (needed for Turing completeness)
\end{itemize}
\glec{Semantics requires environment, heap, stack, references, \ldots}
\end{frame}

\begin{frame}\frametitle{Redundant Computational Semantics}
\begin{blockitems}{Multiple computational semantics}
\item Specification: absolute as rules on paper
\item Interpreter: absolute as implementation
\item Compiler: relative via translation to assembly $L$
 \glec{write $\models E\rewrites V$ for $\vdash_L \sem{E}\rewrites \sem{V}$}
\item Cross-compilation: relative via translation into other languages
 \glec{Church-Turing thesis: always possible}
\end{blockitems}

\begin{blockitems}{Equivalence Theorems}
\item Correctness of compiler: $\vdash E\rewrites V$ iff $\models E\rewrites V$
\glec{accordingly for other translations}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Relationships to other judgments}
\begin{blockitems}{Big Step vs. Small Step}
 \item big step: $\vdash^l_V e\rewrites e'$ is the entire evaluation
 \item small step: $\vdash^l_V e\rewrites e'$ is just one step and semantics requires exhaustive chaining of steps
\end{blockitems}

\begin{blockitems}{Typing}
 \item subject reduction: if $\vdash e:E$, then $\vdash \Eval(e):E$
\end{blockitems}

\begin{blockitems}{Deductive semantics with equality}
 \item normal forms:
  \begin{itemize}
  \item $\Eval^l_V$ idempotent, i.e., $\Eval^l_V(x)=x$ if $x$ value
  \item $\vdash^l_V e\doteq_E\Eval^l_V(e)$
  \end{itemize} 
 \item canonical forms: $\vdash^l_V e_1\doteq_E e_2$ iff $\Eval^l_V(e_1)=\Eval^l_V(e_2)$
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Interdefinability}
\begin{blockitems}{Given a computational semantics, define a deductive one:}
\item distinguished expression $\vdash \true:\prop$,
\item $\vdash F$ iff $\Eval(F)=\true$
\lec{implies decidability, so usually only possible for some $F$}
\end{blockitems}

\begin{blockitems}{Given a deductive semantics, define computational one:}
\item $\Eval(e)$ is some $e'$ such that $\vdash e\doteq e'$
\lec{trivially normal, but usually not canonical}
\end{blockitems}

Both kinds of semantics add different value. We usually want both.
\end{frame}

\section{Contexts and Substitutions}

\begin{frame}\frametitle{Syntax with Contexts}
If we want to talk about contexts, too, we need to expand all of the above.

\begin{blockitems}{Syntax with contexts}
\item contexts: for every $V$, a set $\Cont^l_V$
 \glec{write $\vdash_V \Gamma$}
\item substitutions: for $\Gamma,\Delta\in\Cont_V$, a set $\Subs_V(\Gamma,\Delta)$
 \glec{write $\vdash_V \gamma:\Gamma\to\Delta$}
\end{blockitems}

\begin{blockitems}{Expressions in context}
\item expressions: sets $\Exp_V(\Gamma)$
\item substitution application: functions $\Exp(\gamma):\Exp(\Gamma)\to\Exp(\Delta)$ for $\gamma\in\Subs(\Gamma,\Delta)$
\glec{write $\Exp(\gamma)(e)$ as $e[\gamma]$}
\end{blockitems}

\begin{blockitems}{Typing in context}
\item expressions: sets $\Exp_V(\Gamma,E)$, written as $\Gamma\vdash_V e: E$
\item substitution preserves types: if $\Gamma\vdash e:E$ and $\vdash \gamma:\Gamma\to\Delta$, then $\Delta\vdash e[\gamma]:E[\gamma]$
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Contexts: General Definition}
We can leave contexts abstract or spell out a concrete definition:
\begin{itemize}
\item contexts $\Gamma$ are of the form \[x_1:E_1,\ldots,x_n:E_n\]
 where $E_i\in\Exp(x_1:E_1,\ldots,x_{i-1}:E_{i-1})$
\item for $\Gamma$ as above, substitutions $\Gamma\to \Delta$ are of the form: \[x_1=e_1,\ldots,x_n=e_n\]
 where $\Delta\vdash e_i: E_i[x_1=e_1,\ldots,x_{i-1}=e_{i-1}]$
\end{itemize}
\medskip

This works uniformly for any formal system.
But most formal systems are a bit more restrictive, e.g., by requiring that all $E_i$ are types.
\end{frame}

\begin{frame}\frametitle{Semantics with Contexts}
\begin{blockitems}{Deductive semantics}
\item define: theorem sets $\Thm_V(\Gamma)$
 \glec{write $F\in\Thm_V(\Gamma)$ as $\Gamma\vdash_V F$}
\item such that theorems are preserved by substitution: \\
 if $\Gamma\vdash_V F$ and $\vdash \gamma:\Gamma\to\Delta$, then $\Delta\vdash_V F[\gamma]$
\end{blockitems}

\begin{blockitems}{Computational semantics}
\item define: evaluation functions $\Eval_V(\Gamma):\Exp_V(\Gamma)\to\Exp_V(\Gamma)$
  \glec{write $e'=\Eval_V(\Gamma)(e)$ as $\Gamma\vdash_V e\rewrites e'$}
\item extend to substitutions: $\Eval_V(\Delta)(\ldots,x=e,\ldots)\;=\;\ldots,x=\Eval_V(\Delta)(e), \ldots$
\item require that evaluation is preserved by substitution $\vdash \gamma:\Gamma\to\Delta$ \\
  $\Eval_V(\Delta)(e[\gamma])=\Eval_V(\Delta)(e)[\Eval_V(\Delta)(\gamma)]$
\glec{substitution theorem for $\Eval$ as a translation from $l$ to itself}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Definitions for Substitutions}
\begin{itemize}
\item write $\cdot$ for empty context/substitution
\item ground expression is expression in empty context
 \glec{also called closed; then opposite is open}
\item ground substitution: $\vdash \gamma:\Gamma\to \es$
 \glec{no free variables after substitution}
\item if we have computational semantics: \\ value substitution is ground substitution where all expressions are values
\item if we have deductive semantics: \\
 true instance of $\Gamma\vdash F:\prop$ is $\gamma$ such that $\vdash F[\gamma]$
\end{itemize}
\end{frame}

\section{Concrete Semantics}

\begin{frame}\frametitle{Concrete Semantics}
\begin{blockitems}{Definition}
\item determines the true instances of propositions
\item for every $\Gamma\vdash^l_V F:\prop$, a set $\Inst^l_V(\Gamma,F)$ of ground substitutions
 \glec{write $\vdash^l_V\gamma:\Gamma$ and $\vdash F[\gamma]$ for $\gamma\in\Inst_V(\Gamma,F)$}
\end{blockitems}

\begin{blockitems}{Terminology}
\item Query languages (in the usual, narrower sense than used here): languages plus concrete semantics
\item Database: implementation of concrete semantics
 \lec{usually optimized for fast query answering}
\end{blockitems}

\begin{blockitems}{Examples}
\item SQL for Church-typed ontologies with ADTs (relational databases)
\item SPARQL for Curry-typed ontologies (triple stores)
\item Prolog for first-order logic
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Yes/No vs. Wh-Questions}
Deductive/concrete semantics may be a bit of a misnomer
\begin{itemize}
\item Queries about $\vdash F$ are yes/no questions
 \begin{itemize}
 \item specialty of deductive semantics
 \item but maybe only because everything else is ever harder to do deductively
 \end{itemize}
\item Queries about ground instances of $\Gamma \vdash F$ are Wh questions
 \begin{itemize}
 \item specialty of concrete databases
 \item for the special case of retrieving finite results sets from a fixed concrete store
 \item only situation where Wh questions are easy
 \end{itemize}
\end{itemize}
But Yes/no and Wh questions exist in all aspects.
\end{frame}

\begin{frame}\frametitle{Redundant Concrete Semantics}
\begin{blockitems}{Multiple concrete semantics}
\item Specification: absolute as rules on paper
\item Database: absolute by custom database
\item Database: relative via translation to assembly $L$
\end{blockitems}

\begin{blockitems}{Equivalence Theorems}
\item typically: choose one, no redundancy, no equivalence theorems
\item infinite results: easy on paper, hard in database
\item open world: are all known ground instances in database?
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Interdefinability}
\begin{blockitems}{Given concrete semantics, define a deductive one}
\item for ground $F$, $\Inst(\cdot,F)$ is either $\{\cdot\}$ or $\{\}$
\item $\vdash F$ iff $\Inst(\cdot, F)=\{\cdot\}$
\lec{but concrete semantics usually cannot find all substitutions for all $F$}
\end{blockitems}

\begin{blockitems}{Given concrete semantics, define a computational one}
\item $\vdash e\rewrites e'$ iff $(x=e')\in\Inst(x:E, e\doteq_E x)$
\lec{but concrete semantics usually cannot find that substitution for all $e$}
\end{blockitems}

\begin{blockitems}{Given deductive semantics, define a concrete one}
\item $\Inst(\Gamma,F)=\{\vdash \gamma:\Gamma\to\cdot \;|\;\vdash F[\gamma]\}$
\lec{but deductive semantics usually does not allow computing that set}
\end{blockitems}

\begin{blockitems}{Given computational semantics, define a concrete one}
\item $\Inst(\Gamma,F)=\{\Eval(\cdot,\gamma) \;|\;\vdash \gamma:\Gamma\to\cdot, \;\vdash F[\gamma]\rewrites \true\}$
\item allows restricting results to value substitutions
\lec{composition of previous inter-definitions, inherits both problems}
\end{blockitems}
\end{frame}

\section{Narrative Semantics}

\begin{frame}\frametitle{Narrative Semantics}
\begin{blockitems}{Definition}
\item Describes how to answer (some) questions
\item Implementations tend to be AI-complete, hypothetical
\item In practice, information retrieval = find related documents
\end{blockitems}

\begin{blockitems}{More precisely?}
\item Not much theory, wide open research problem
\item Some natural language document with interspersed definitions, formulas
\item Maybe judgment: $\vdash Q ? A$ for ``$A$ is answer to $Q$''
\end{blockitems}

\begin{blockitems}{Examples}
\item ``W3C Recommendation OWL 2'' and Google
\item ``ISO/IEC 14882: 1998 Programming Language C++'' and Stroustrup's book
\item Mathematics textbooks and mathematicians
\end{blockitems}
\end{frame}

%\begin{frame}\frametitle{Abstract vs. Concrete Semantics}
%\begin{blockitems}{Abstract}
%\item $\Exp$, $\Thm$, $\Eval$ just assumed as sets/functions
%\item No requirement how they are constructed
% \begin{itemize}
% \item inductive structure of expressions optional
% \item both absolute and relative semantics are special cases
%\end{itemize}
%\end{blockitems}
%
%\begin{blockitems}{Concrete, e.g.,}
%\item $\Exp_V$ defined by grammar
%\item rule system defined by
% \begin{itemize}
% \item calculus for $\vdash_V e:E$
% \item alternatively: trivial type system where \\
%  all non-terminals $N$ are expressions too \\
%  and $\vdash E:N$ iff $E$ derived from $N$
% \end{itemize}
%\item $\Thm_V$ defined by calculus for $\vdash_V F$
%\item $\Eval_V$ defined by calculus for $\vdash_V e \rewrites e'$
%\end{blockitems}
%\end{frame}

\section{Relative Semantics}

\begin{frame}\frametitle{Translations}
\begin{blockitems}{A translation $T$ from formal system $l$ to formal system $L$ consists of}
\item function $\Voc^T:\Voc^l\to\Voc^L$
\item family of functions $\Exp^T_V:\Exp^l_V\to\Exp^L_{\Voc^T(V)}$
\end{blockitems}

\begin{blockitems}{Desirable properties}
\item Should satisfy type preservation:
\[\vdash^l_V e:E \tb\mimplies\tb \vdash^L_{\Voc^T(V)} \Exp^T_V(e):\Exp^T_V(E)\]
\lec{intuition: what we have, is preserved}
\item Might satisfy type reflection/conservativity: 
\[\vdash^L_{\Voc^T(V)} e':\Exp^T_V(E) \tb\mimplies\tb \vdash^l_V e:E \mforsome e\]
\lec{intuition: nothing new is added}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Translation of Contexts}
\begin{blockitems}{Translations extend to contexts and substitutions}
 \item $\Cont^T(\ldots,x:E,\ldots) \;=\;\ldots, x:\Exp^T(E), \ldots$
 \item $\Subs^T(\ldots,x=e,\ldots) \;=\;\ldots, x=\Exp^T(e), \ldots$
 \item $\Exp^T(x)=x$ for all variables
\end{blockitems}

\begin{blockitems}{Desirable properties for arbitrary contexts}
\item Type preservation:
\[\Gamma\vdash^l_V e:E \tb\mimplies\tb \Cont^T_V(\Gamma)\vdash^L_{\Voc^T(V)} \Exp^T_V(e):\Exp^T_V(E)\]
\item Conservativity:
\[\Cont^T_V(\Gamma)\vdash^L_{\Voc^T(V)} e':\Exp^T_V(E) \tb\mimplies\tb \Gamma\vdash^l_V e:E \mforsome e\]
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Compositionality}
Define: a translation is compositional iff we can show the substitution theorem for it

Given
\[\Gamma\vdash^l_V e:E \tb\vdash^l_V \gamma:\Gamma\to\Delta\]
we have that
\[\Cont^T_V(\Delta)\vdash^L_{\Voc^T(V)}\Exp^T_V(e[\gamma])\doteq_{\Exp^T_V(E[\gamma])}\Exp^T_V(e)[\Subs^T_V(\gamma)] \]

Simplify: write
$T(-)$ for $\Voc^T(-), \Exp_V^T(-)$, $\Cont_V^T(-)$, $\Subs_V^T(-)$
\[T(\Delta)\vdash^L_{T(V)}T(e[\gamma])\doteq_{T(E[\gamma])}T(e)[T(\gamma)] \]
\end{frame}

\begin{frame}\frametitle{Relative Semantics}
Given
 \begin{itemize}
 \item formal systems $l$ and $L$
 \item semantics for $L$
 \item translation $T$ from $l$ to $L$
 \end{itemize}
define semantics for $l$
\medskip

\begin{itemize}
\item deductive: define
 \[\vdash^l_V F \tb\miff\tb \vdash^L_{\Voc^T(V)} \Exp^T_V(F) \]
\item computational: define
 \[\vdash^l_V e\rewrites e' \tb\miff\tb \vdash^L_{\Voc^T(V)}\Exp^T_V(e)\rewrites \Exp^T_V(e')\]
\glec{both work accordingly with a context $\Gamma$}
\item concrete: define
 \[\Gamma\vdash^l_V \gamma:F \tb\miff\tb \Cont^T_V(\Gamma)\vdash^L_{\Voc^T(V)}\Subs^T_V(\gamma):\Exp^T_V(F)\]
\end{itemize}
\end{frame}


\section{Equivalence of Semantics}

\begin{frame}\frametitle{Definition}
Two semantics $\vdash^1$ and $\vdash^2$ for $l$ are equivalent if
\begin{itemize}
\item deductive: $\vdash^1 F$ iff $\vdash^2 F$
\item computational: $\vdash^1 e\rewrites e'$ iff $\vdash^2 e\rewrites e'$
\item concrete: $\Gamma\vdash^1 \gamma:F$ iff $\Gamma\vdash^2 \gamma:F$
\end{itemize}

Example for deductive semantics:
\begin{itemize}
\item $\vdash^1$ absolute semantics by calculus \\
 e.g., natural deduction for SFOL
\item $\vdash^2$ relatives semantics by translation
 e.g., $L$ is set theory, $T$ is model theory of SFOL
\item Assume proofs-as-expressions
\item Then:
 \begin{itemize}
 \item type preservation = soundness
 \item conservativity = completeness
 \end{itemize}
\end{itemize}
\end{frame}

% \begin{frame}\frametitle{Exercise 6: Relative Deductive Semantics for BOL}
% \begin{itemize}
% \item Implement a translation from BOL to untyped FOL
 % \glec{you can drop properties, types, and values}
 % \glec{so that only one type of individuals is needed}
% \item Use TPTP syntax for FOL
 % \glec{see \url{http://www.tptp.org/}}
% \item Translate an example ontology
  % \glec{pick any ontology with a non-trivial consequence closure}
% \item Use a theorem prover for first-order logic to implement a relative deductive semantics for BOL
  % \glec{Vampire and E are standard choices}
  % \glec{see also \url{http://www.tptp.org/cgi-bin/SystemOnTPTP}}
% \item Test by example whether your semantics yields the correct consequence closure
% \end{itemize}
% \end{frame}

\begin{frame}\frametitle{Example: Relative Computational Semantics for BOL}
Scala, SQL semantics evaluates
\begin{itemize}
\item concept $c$ to
\begin{itemize}
\item SQL: table of individuals
 \lec{result of running query $\sem{c}$}
\item Scala: hashset of individuals
 \lec{result of running program $\sem{c}$}
\end{itemize}
\item propositions to booleans \lec{accordingly}
\end{itemize}

Technically, results not in image of $\sem{-}$\\
Fix: add productions for all values
\begin{commgrammar}
\gprod{F}{\true\bnfalt \false}{truth values}\\
\gprod{C}{\{I,\ldots,I\}}{finite concepts}
\end{commgrammar}
\end{frame}

\begin{frame}\frametitle{Equivalence with respect to Semantics}
So far: equivalence of \emph{two semantics} wrt \emph{all queries}

Related concept: equivalence of \emph{two queries} wrt \emph{one semantics}
\begin{itemize}
\item $F$, $G$ deductively equivalence: \[\vdash F \tb\miff\tb \vdash G\]
\glec{may be internalized by syntax as proposition $F\equiv G$}
\item $F,G$ concretely equivalent: \[\vdash F[\gamma] \tb\miff\tb \vdash G[\gamma]\] for all ground substitutions $\gamma$
\glec{weaker than $\Gamma\vdash F\equiv G$}
\item closed $e,e'$ computationally equivalent: \[\vdash e\rewrites v \tb\miff\tb \vdash e'\rewrites v\]
\glec{may be internalized by syntax as proposition $e\doteq e'$}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Equivalence with respect to Semantics (2)}
Interesting variants of computational semantics
\begin{itemize}
\item open $e,e'$ extensionally equivalent:
  \[\vdash e[\gamma]\rewrites v \tb\miff\tb \vdash e'[\gamma]\rewrites v\]
  for all ground substitutions $\gamma$
 \lec{equal inputs produce equal outputs}
 \glec{weaker then $\Gamma\vdash e\doteq e'$ --- intensional equivalence}
\item machines $M,M'$ observationally equivalent: \\
  produce equal sequences of outputs for the same sequence of inputs
  \glec{e.g., automata, objects in OO-programming}
\end{itemize}

\lec{choice of semantics defines legal optimizations in compiler}
\end{frame}

\begin{frame}\frametitle{Equivalence of BOL Semantics}
Now $5$ semantics for BOL
\begin{itemize}
\item absolute deductive via calculus
\item relative deductive via SFOL
\item relative computational via Scala
\item relative concrete via SQL
\item relative narrative via English
\end{itemize}
Moreover, these are interdefinable.
\glec{e.g., Scala translation also induces deductive semantics}

Can compare equivalence
\begin{itemize}
\item for every pair of semantics
\item for every kind of equivalence (deductive, concrete, computational)
\end{itemize}
Question: Which of them hold?
\end{frame}

\begin{frame}\frametitle{Questions}
For example, consider:
\begin{itemize}
\item Are the absolute semantics and the Scala semantics deductively equivalent?
\item Assuming BOL and SQL have the base types and values:
Are the absolute semantics and the SQL semantics concretely equivalent?
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Deductive Semantics of BOL}
Are these two BOL semantics deductively equivalent
\begin{itemize}
\item absolute deductive semantics 
\item relative deductive semantics via translation $\sem{-}$ to SFOL
\end{itemize}

\only<1>{
Soundness: $\vdash^{BOL}_V f$ implies $\vdash^{SFOL}_{\sem{V}}\sem{f}$ \\
 \begin{itemize}
 \item induction on derivations of $\vdash^{BOL}_V f$
 \item one case per rule
    \glec{induction rule from above not sound}
 \item several pages of work but straightforward and relatively easy
 \end{itemize}
}
\only<2>{
Completeness: $\vdash^{BOL}_V f$ implied by $\vdash^{SFOL}_{\sem{V}}\sem{f}$
 \glec{works if we add missing rules}
\begin{itemize}
\item induction on SFOL derivations does not work
 \begin{itemize}
 \item SFOL more expressive than BOL
 \item $\sem{-}$ not surjective
 \end{itemize}
\item instead show that $\sem{-}$ preserves consistency of vocabularies
 \glec{no universal recipe how to do that}
\item then a typical proof uses $V$ extended with $\neg f$
 \begin{itemize}
 \item if $V$ inconsistent, $\vdash_V f$ for all $f$, done
 \item if $V$ consistent and $V+\neg f$ inconsistent, then $\vdash_V f$, done
 \item if $V+\neg f$ consistent, so is $\sem{V+\neg f}$, which contradicts $\vdash^{SFOL}_{\sem{V}}\sem{f}$
 \end{itemize}
\end{itemize}
}
\end{frame}

\begin{frame}\frametitle{Computational Semantics of BOL}
Are these two BOL semantics deductively equivalent
\begin{itemize}
\item absolute deductive semantics 
\item relative deductive semantics via translation $\sem{-}$ to Scala
\end{itemize}

\only<1>{
Soundness: $\vdash^{BOL}_V f$ implies $\vdash^{Scala}_{\sem{V}}\sem{f}\rewrites \true$
\begin{itemize}
\item Problem: Absolute semantics performs consequence closure, e.g.,
\begin{itemize}
\item transitivity of $\sqsubseteq$
\item relationship between $\sqsubseteq$ and $\isa$
\end{itemize}
\item Scala semantics does so only if we explicitly implemented it
\glec{we didn't}
\glec{same problem for SQL semantics}
\end{itemize}
}

\only<2>{
Completness: $\vdash^{BOL}_V f$ implied by $\vdash^{Scala}_{\sem{V}}\sem{f}\rewrites \true$
\begin{itemize}
 \item absolute semantics leaves closed world optional
 \item Scala uses closed worlds
  \glec{e.g., used to compute $c\sqsubseteq d$ by checking all individuals} 
 \item complete only if we add induction rule
\end{itemize}
}
\end{frame}
