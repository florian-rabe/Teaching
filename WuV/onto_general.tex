\section{General Principles}

\paragraph{Motivation}
An ontology is an abstract representation of the main concepts in some domain.
Here \emph{domain} refers to any area of the real world such as mathematics, biology, diseases and medications, human relationships, etc.
Many examples can be found at \url{https://bioportal.bioontology.org/}, including the Gene ontology one of the biggest.

Contrary to the other four aspects, ontological knowledge representations do not aim at capturing the entire semantics of the domain objects.
Instead, they focus on defining unique identifiers for the those objects and describing some of their properties and relations to each other.

We use the word \textbf{ontologization} to refer to the process of organizing the knowledge of a domain in ontologies.

Ontologies are most valuable when they are \emph{standardized} (either sanctioned through a formal body or a quasi-standard because everyone uses it).
A standard ontology allows everybody in the domain to use the identifiers defined by the ontology in a way that avoids misunderstandings.
Thus, in the simplest form, an ontology can be seen as a dictionary defining the technical terms of a domain.
For example, the Gene ontology defines identifier \texttt{GO:0000001} to have the formal name "mitochondrion inheritance" and the informal definition "The distribution of mitochondria, including the mitochondrial genome, into daughter cells after mitosis or meiosis, mediated by interactions between mitochondria and the cytoskeleton.".

\paragraph{Ontology Languages}
An ontology is written in \textbf{ontology language}.
Common ontology languages are
\begin{compactitem}
 \item description logics such as ALC,
 \item the W3C ontology language OWL, which is the standard ontology languages of the semantic web,
 \item the entity-relationship model, which focuses on modeling rather than formal syntax,
 \item modeling languages like UML, which is the main ontology language used in software engineering.
\end{compactitem}

Ontology languages are not committed to a particular domain --- in the Tetrapod model, they correspond to programming languages and logics, which are similarly uncommitted.
Instead, an ontology language is a formal language that standardizes the syntax of how ontologies can be written as well as their semantics.

\paragraph{Ontologies}
The details of the syntax vary between ontology languages.
But as a general rule, every \textbf{ontology} declares
\begin{compactitem}
 \item \textbf{individual} --- concrete objects that exist in the real world, e.g., "Florian Rabe" or "WuV"
 \item \textbf{concept} --- abstract groups of individuals, e.g., "instructor" or "course"
 \item \textbf{relation} --- binary relations between two individuals, e.g., "teaches"
 \item \textbf{properties} --- binary relations between an individuals and a concrete value (a number, a date, etc.), e.g., "has-credits"
 \item \textbf{concept assertions} --- the statement that a particular individual is an instance of a particular concept
 \item \textbf{relation assertions} --- the statement that a particular relation holds about two individuals
 \item \textbf{property assertions} --- the statement that a particular individual has a particular value for a particular property
 \item \textbf{axioms} --- statements about relations between concepts, typically in the form subconcept of statements like "instructor" $\sqsubseteq$ "person"
\end{compactitem}

All assertions can be understood and spoken as subject-predicate-object \textbf{triples} as follows:
\begin{center}
\begin{tabular}{l|lll}
Assertion & \multicolumn{3}{c}{Triple} \\
          & Subject & Predicate & Object \\
\hline
concept assertion  & "Florian Rabe" & \texttt{is-a} & "instructor" \\
relation assertion & "Florian Rabe" & "teaches" & "WuV" \\
property assertion & "WuV" & "has credits" & 7.5 \\
\end{tabular}
\end{center}
This uses a special relation \texttt{is-a} between individuals and concepts.
Some languages group \texttt{is-a} with the other binary relations between individuals for simplicity although it is technically a little different.

The possible values of properties must be fixed by the ontology language.
Typically, it includes at least standard types such as integers, floating point numbers, and strings.
But arbitrary extensions are possible such as dates, RGB-colors, lists, etc.
In advanced languages, it is possible that the ontology even introduces its own basic types and values.

Ontologies are often divided into two parts:
\begin{compactitem}
 \item The \textbf{abstract} part contains everything that holds in general independent of which individuals: concepts, relations, properties, and axioms.
 It describes the general rules how the worlds works without committing to a particular set of inhabitants of the world.
 This part is commonly called the \textbf{TBox} (T for terminological).
 \item The \textbf{concrete} part contains everything that depends on the choice of individuals: individuals and assertions.
 It populates the world with inhabitants.
 This part is commonly called the \textbf{ABox} (A for assertional).
\end{compactitem}

A separate division into two parts is the following:
\begin{compactitem}
 \item The \textbf{signature} part contains everything that introduces a \textbf{named entity}: individuals, concepts, relations, and properties.
 \item The \textbf{theory} part contains everything that describes which statements about the named entities are true: assertions and axioms.
\end{compactitem}


\paragraph{Synonyms}
Because these principles pervade all formal languages, many competing synonyms are used in different domains.
Common synonyms are:
\begin{center}
\begin{tabular}{l|llll|l}
 Here       & OWL      & Description logics & ER model & UML & semantics via logics\\
\hline
 individual & instance & individual & entity & object, instance & constant\\
 concept    & class    & concept &  entity-type & class & unary predicate\\
 relation   & object property & role & role & association & binary predicate \\
 property   & data property   & (not common) & attribute & field of base type & binary predicate\\
\end{tabular}
\end{center}

In particular, the individual-concept relation occurs everywhere and is known under many names:
\begin{center}
\begin{tabular}{l|ll}
 domain & individual & concept \\
\hline
type theory, logic & constant, term & type \\
set theory  & element & set \\
database    & row & table \\
philosophy\footnote{as in \url{https://plato.stanford.edu/entries/object/}} & object & property \\
grammar & proper noun & common noun \\
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Basic Ontology Language}

\begin{figure}[hbt]
\begin{commgrammar}
\gcomment{Ontologies}\\
\gprod{O}{\rep{D}}{}\\
\gcomment{Declarations}\\
\gprod{D}{\kw{individual}\; \ID}{atomic individual}\\
\galtprod{\kw{concept}\; \ID}{atomic concept}\\
\galtprod{\kw{relation}\; \ID}{atomic relation}\\
\galtprod{\kw{property}\; \ID: T}{atomic property}\\
\galtprod{I\; \texttt{is-a}\; C}{concept assertion}\\
\galtprod{I\; R\; I}{relation assertion}\\
\galtprod{I\; P\; V}{property assertion}\\
\galtprod{F}{other axioms}\\
\gcomment{Formulas}\\
\gprod{F}{C \Equiv C}{concept equality}\\
\galtprod{C \sqsubseteq C}{concept subsumption}\\
\gcomment{Individual expressions}\\
\gprod{I}{\ID}{atomic individuals}\\
\gcomment{Concept expressions}\\
\gprod{C}{\ID}{atomic concepts}\\
\galtprod{C \sqcup C}{union of concepts}\\
\galtprod{C \sqcap C}{intersection of concepts}\\
\galtprod{\forall R.C}{universal relativization}\\
\galtprod{\exists R.C}{existential relativization}\\
\galtprod{\dom R}{domain of a relation}\\
\galtprod{\rng R}{range of a relation}\\
\gcomment{Relation expressions}\\
\gprod{R}{\ID}{atomic relations}\\
\galtprod{R \cup R}{union of relations}\\
\galtprod{R \cap R}{intersection of relations}\\
\galtprod{R ; R}{composition of relations}\\
\galtprod{R^*}{transitive closure of a relation}\\
\galtprod{R^{-1}}{dual relation}\\
\galtprod{\Delta_C}{identity relation of a concept}\\
\gcomment{Property expressions}\\
\gprod{P}{\ID}{atomic properties}\\
\gcomment{Identifiers}\\
\gprod{\ID}{\text{alphanumeric string}}{}\\
\gcomment{Basic types and values}\\
\gprod{T}{\itg \alt \float \alt \bool \alt \strg}{types}\\
\gprod{T}{\text{(omitted)}}{values}
\end{commgrammar}
\caption{Grammar of BOL}\label{fig:bol}
\end{figure}

\clearpage

We could study practical ontology languages like ALC or OWL now.
But those feature a lot of other details that can block the view onto the essential parts.
Therefore, we first define a basic ontology language ourselves in order to have full control over the details.

\subsection{Syntax}

\begin{definition}[Syntax of BOL]
A BOL-ontology is given by the grammar in Fig.~\ref{fig:bol}.
It is well-formed if
\begin{compactitem}
 \item no identifier is declared twice,
 \item every property assertion assigns a value of the type required by the property declaration,
 \item every reference to an atomic individual/concept/relation/property is declared as such.
\end{compactitem}
\end{definition}

The above grammar exhibits some general structure that we find throughout formal KR languages.
In particular, an ontology consists of \textbf{named declarations} of four different kinds of entities as well as some assertions and axioms about them.
Each entity declaration clarifies which kind it is (in our case by starting with a keyword) and introduces a new entity identifier.
For each kind, there are complex expressions.
These are anonymous and built inductively; their base cases are references to the corresponding identifiers.
Sometimes (in our case: individuals and properties), the references are the only expressions of the kind.
Sometimes (in our case: concepts and relations), there can be many productions for complex expressions.
The complex expressions are used to build axioms; in our case, these are the three kinds of assertions and other formulas.

\subsection{Deductive Semantics}

We give a semantics of BOL as an example of a semantics by translation.
We fix one language that we have already understood and define an interpretation function that maps all complex expression of the syntax into the semantic language.
Specifically, we give a deductive/logical semantics, i.e., the semantic language is a logic.

For simple ontology languages like BOL, ALC, OWL, etc., it is common to use first-order logic (FOL) as the semantic language.
More specifically, we use SFOL, the typed variant of FOL with
\begin{definition}[Logical Semantics of BOL]
The \textbf{semantic prefix} $P$ is the FOL-theory containing
\begin{compactitem}
 \item a type $\iota$ (for individuals),
 \item additional types and constants corresponding to base types and values of BOL.
\end{compactitem}

Then every BOL-ontology $O$ is interpreted as the FOL-theory $P,\sem{O}$, where $\sem{O}$ is defined in Fig.~\ref{fig:bolsem}.
\end{definition}

Like with the syntax, we can observe some general principles.
Every BOL-declaration is translated to a FOL declaration for the same name, and ontologies are translated declaration-wise.
For every kind of complex expression, there is one inductive function mapping BOL-expressions to FOL-expressions.
The base cases of references to declared identifiers are translated to themselves, i.e., to the identifiers of the same name declared in the FOL theory.
The other cases are compositional: every case for a complex expression recurses only into the semantics of the direct subexpressions.

The role of the semantic prefix $P$ is to define once and for all the FOL material that we need in general to interpret ontologies.
It occurs at the beginning of all interpretations of ontologies.
In particular, it is equal to the interpretation of empty ontology.

\begin{figure}\centering
\begin{tabular}{l|l}
BOL Syntax $X$ & Semantics $\sem{X}$ in FOL\\
\hline
\hline
ontology & FOL theory \\
$D_1,\ldots,D_n$ & $\sem{D_1},\ldots,\sem{D_n}$ \\
\hline
BOL declaration & FOL declaration \\
\kw{individual}\,$i$ & nullary function symbol $i:\iota$ \\
\kw{concept}\,$i$  & unary predicate symbol $i\sq\iota$ \\
\kw{relation}\,$i$ & binary predicate symbol $i\sq\iota\times \iota$ \\
\kw{property}\,$i:T$ & binary predicate symbol $i\sq\iota\times T$ \\
$I\; \texttt{is-a}\; C$ & axiom $\sem{C}(\sem{I})$\\
$I_1\; R\; I_2$ & axiom $\sem{R}(\sem{I_1},\sem{I_2})$\\
$I\; P\; V$ & axiom $\sem{P}(\sem{I},\sem{V})$\\
$F$ & axiom $\sem{F}$\\
\hline
Formula & Formula without free variables\\
$C_1 \Equiv C_2$ & $\forall x:\iota.\sem{C_1}(x)\Leftrightarrow \sem{C_2}(x)$\\
$C_1 \sqsubseteq C_2$ & $\forall x:\iota.\sem{C_1}(x)\impl \sem{C_2}(x)$\\
\hline
Individual & Terms of type $\iota$ \\
$i$ & $i$ \\
\hline
Concept & Formula with free variable $x:\iota$\\
$i$ & $i(x)$\\
$C_1 \sqcup C_2$ & $\sem{C_1}(x)\vee\sem{C_2}(x)$\\
$C_1 \sqcap C_2$ & $\sem{C_1}(x)\wedge\sem{C_2}(x)$\\
$\forall R.C$    & $\forall y:\iota.\sem{R}(x,y)\impl \sem{C}(y)$\\
$\exists R.C$    & $\exists y:\iota.\sem{R}(x,y)\wedge \sem{C}(y)$\\
$\dom\, R$ & $\exists y:\iota.\sem{R}(x,y)$\\
$\rng\, R$ & $\exists y:\iota.\sem{R}(y,x)$\\
\hline
Relation & Formula with free variables $x:\iota,y:\iota$\\
$i$ & $i(x,y)$\\
$R_1 \cup R_2$ & $\sem{R_1}(x,y)\vee \sem{R_2}(x,y)$\\
$R_1 \cap R_2$ & $\sem{R_1}(x,y)\wedge \sem{R_2}(x,y)$\\
$R_1 ; R_2$ & $\exists m:\iota.\sem{R_1}(x,m)\wedge \sem{R_2}(m,y)$\\
$R^{-1}$          & $\sem{R}(y,x)$\\
$R^*$          & (tricky, omitted)\\
$\Delta_C$     & $x\doteq y\wedge \sem{C}(x)$\\
\hline
Property of type $T$ & Formula with free variables $x:\iota,y:T$\\
$i$ & $i(x,y)$\\
\end{tabular}
\caption{Interpretation Function for BOL into FOL}\label{fig:bolsem}
\end{figure}

\subsection{Concretized Semantics}

We give an alternative semantics using a semantic language for concrete data.
Specifically we focus on the SQL database language.

Even though this is a very different knowledge aspect, the general principles of the semantics are the same:
Every BOL-declaration is translated to an SQL declaration, and ontologies are translated declaration-wise.
For every kind of complex expression, there is one inductive function mapping BOL-expressions to SQL-expressions.

In SQL, we can nicely see the difference between declarations and expressions: the former are translated to side effect-ful statements, the latter to side effect-free queries.

\begin{definition}[Concretized Semantic of BOL]
The \textbf{semantic prefix} consists of the following SQL statements
\begin{compactitem}
 \item a type $ID$ of identifiers (if not already supported anyway by the underlying database)
 \item declarations of all base types and values of BOL (if not already supported anyway by the underlying database)
 \item CREATE TABLE individuals (id ID, name string), where the id field is unique and automatically generated when inserting values
\end{compactitem}

Every BOL-ontology $O$ is interpreted as a sequence $P,\sem{O}$ of SQL statements, where $\sem{O}$ is defined in Fig.~\ref{fig:bolsemsql}.
\end{definition}

\begin{figure}\centering
\begin{tabular}{l|l}
BOL Syntax $X$ & Semantics $\sem{X}$ in SQL\\
\hline
\hline
ontology & SQL statements \\
$D_1,\ldots,D_n$ & $\sem{D_1},\ldots,\sem{D_n}$ \\
\hline
BOL declaration ($I$, $C$, $R$ atomic) & SQL statement \\
\kw{individual}\,$i$ & INSERT INTO individuals (name) VALUES ($i$) \\
\kw{concept}\,$i$  & CREATE TABLE $i$ (id ID)\\
\kw{relation}\,$i$ & CREATE TABLE $i$ (subject ID, object ID) \\
\kw{property}\,$i:T$ & CREATE TABLE $i$ (subject ID, object $T$) \\
$I\; \texttt{is-a}\; C$ & INSERT INTO $C$ VALUES ($\sem{I}$)\\
$I_1\; R\; I_2$ & INSERT INTO $R$ (subject, object) VALUES ($\sem{I_1}$, $\sem{I_2}$)\\
$I\; P\; V$ & INSERT INTO $P$ (subject, object) VALUES ($\sem{I}$, $V$)\\
$F$ & consistency check, consequence closure (omitted)\\
\hline
Formula & Query that returns empty result iff formula is true \\
$C_1 \Equiv C_2$ & $(\sem{C_1}\sm\sem{C_2})$ UNION $(\sem{C_2}\sm\sem{C_1})$\\
$C_1 \sqsubseteq C_2$ & $\sem{C_1}\sm\sem{C_2}$\\
\hline
Individual & an identifier from the table individuals \\
$i$ & SELECT id FROM individuals WHERE name=$i$ \\
\hline
Concept & SQL query for one-column table\\
$i$ & SELECT * FROM $i$\\
$C_1 \sqcup C_2$ & $\sem{C_1}$ UNION $\sem{C_2}$\\
$C_1 \sqcap C_2$ & $\sem{C_1}$ INTERSECT $\sem{C_2}$\\
$\forall R.C$    & individuals $\sm$ (SELECT subject FROM $\sem{R}$ WHERE object NOT IN $\sem{C})$ \\
$\exists R.C$    & SELECT DISTINCT subject FROM $\sem{R}$, $\sem{C}$ WHERE object=id\\
$\dom\, R$ & SELECT DISTINCT subject FROM $\sem{R}$\\
$\rng\, R$ & SELECT DISTINCT object FROM $\sem{R}$\\
\hline
Relation & SQL query for two-column table\\
$i$ & SELECT * FROM $i$\\
$R_1 \cup R_2$ & $\sem{R_1}$ UNION $\sem{R_2}$\\
$R_1 \cap R_2$ & $\sem{R_1}$ INTERSECT $\sem{R_2}$\\
$R_1 ; R_2$ & SELECT DISTINCT l.subject, r.object FROM $\sem{R_1}$ AS l, $\sem{R_2}$ AS r \\
            & \tb\tb WHERE l.object = r.subject\\
$R^{-1}$          & SELECT object, subject FROM $\sem{R}$\\
$R^*$          & (tricky, omitted)\\
$\Delta_C$     & SELECT id AS subject, id AS object FROM $\sem{C}$\\
\hline
Property of type $T$ & SQL query for two-column table\\
$i$ & SELECT * FROM $i$\\
\end{tabular}
\medskip

Using the abbreviation: $S\sm T$ = SELECT id FROM $S$ WHERE id NOT IN $T$\\
\caption{Interpretation Function for BOL into SQL}\label{fig:bolsemsql}
\end{figure}

%\footnotetext{This case is a mini homework.}

\paragraph{Complex Expressions in Assertions}
Our interpretation of BOL in SQL is restricted assertions using only atomic expressions.
For example, in the case for $I$ \texttt{is-a} $C$, we assume that $I$ and $C$ are names.
Thus, we have already created an individual for $I$ and a table for $C$, and we can thus insert the former into the latter.

The general case would be more complicated but is much less important in practice.
For example, the concept assertion "Florian Rabe" \texttt{is-a} "instructor" $\sqcap$ "male" could be handled by adding the individual to both tables.
But other expressions very quickly become more difficult.

\paragraph{Translation of Formulas}
The interpretation of formulas into SQL is less obvious because SQL is not a logic.
We have to consider two subtleties.

Firstly, a formula may express a consistency condition that must not violated by the ontology.
For example, ontologies may contain contradictory assertions or violations of uniqueness constraints such as a person should only have one father or fathers should be male.
In FOL, this amounts to $\sem{O}$ being an inconsistent theory, which can be reasoned about as usual.
In SQL, we can mimic it by checking the consistency of the database.
(Consistency is undecidable for FOL in general but often decidable for ontology languages.)

Secondly, a formula may express a closure operation that must be mimicked by adding implied assertions to the ontology.
For example, if there is a subconcept axiom "instructor" $\sqsubseteq$ "person" and a concept assertion "Florian Rabe" is-a "instructor", we have to add the implied concept assertion "Florian Rabe" is-a "person".
In FOL, this happens automatically by the calculus of FOL, which adds all theorems of a theory.
In SQL, we have to mimic it manually. (Consequence is undecidable for FOL in general but often decidable for ontology languages.)

\subsection{Narrative Semantics}

We will now look at still another semantics for BOL: the \textbf{narrative semantics} is given by translation into a natural language --- here English.

Note that we are relatively open of what kind of English we want to use as a target language.
The simplest choice would be to use plain English, as you could find in a novel or newspaper article.
But for many applications (e.g. STEM ontologies), we would rather use STEM English, i.e. English interspersed with formulas, diagrams, and epistemic cues like ``Definition'', ``Theorem'', ``Proof'', and even $\Box$.
For this kind of English, {\LaTeX} is a good target format.
Finally, we can use flexiformal formats like \sTeX~\cite{Kohlhase:ulsmf08,URL:sTeX:github}, where we can capture more of the semantic properties.

In \Cref{fig:bolsem:narrative1} we present a translation into plain English in the style of the other aspect semantics translations above.
It recursively goes over the BOL expressions and generates strings, using a lexicon function $lex$ (for lexicon) that maps BOL identifiers into (lemmata $\hat=$ base forms of) English words of the appropriate syntactic category for the base cases.

\begin{figure}\centering
\begin{tabular}{l|l}
BOL Syntax $X$ & Narrative Semantics $\sem{X}$ in English\\
\hline\hline
ontology & English document \\
$D_1,\ldots,D_n$ & $\sem{D_1},\ldots,\sem{D_n}$ \\
\hline
BOL declaration & dictionary entry or true sentence\\
\kw{individual}\,$i$ & $lex(i)$ is a proper noun\\
\kw{concept}\,$i$  & $lex(i)$ is a common noun\\
\kw{relation}\,$i$ & $lex(i)$ is a transitive verb \\
\kw{property}\,$i:T$ & $lex(i)$ is a common noun for a property that can take $T$-values \\
%$I\; \texttt{is-a}\; \forall R.C$ & all those that $\sem{I}$ $\sem{R}$s are $\sem{C}$\\
%$I\; \texttt{is-a}\; \exists R. C$ & $\sem{I}$ $\sem{R}$s a $\sem{C}$\\
$I\; \texttt{is-a}\; C$ & $\sem{I}$ $\sem{C}$\\
$I_1\; R\; I_2$ & $\sem{I_1}$ $\sem{R}$ $\sem{I_2}$\\
$I\; P\; V$ & $\sem{I}$ has $\sem{P}$ $\sem{V}$\\ 
$F$ & $\sem{F}$\\
\hline
Formula & Sentence \\
$C_1 \Equiv C_2$ & $\sem{C_1}$ing is the same as $\sem{C_2}$ing\\
%$c \Equiv C$ & $\sem{C_2}$ abbreviates $\sem{C}$ & $c$ a constant\\
$C_1 \sqsubseteq C_2$ & everything that $\sem{C_1}$s also $\sem{C_2}$s\\
\hline
Individual & noun phrase (to be used as a subject or object)\\
$i$ & $lex(i)$ \\
\hline
Concept & intransitive verb phrase (to be plugged after a subject) \\
$i$ & is a $lex(i)$\\
$C_1 \sqcup C_2$ & $\sem{C_1}$ or $\sem{C_2}$\\
$C_1 \sqcap C_2$ & $\sem{C_1}$ and $\sem{C_2}$\\
%$C_1 \sqcap C_2$ & is a $\sem{C_1}$ that $\sem{C_2}$s & $C_1$ simple\\
$\forall R.C$    & $\sem{R}$s only things that $\sem{C}$ \\
$\exists R.C$    & $\sem{R}$s something that $\sem{C}$s\\
$\dom\, R$ & $\sem{R}$s something\\
$\rng\, R$ & is $\sem{R}$ed by something\\
\hline
Relation & transitive verb phrase (to be plugged between subject and object)\\
$i$ & $lex(i)$\\
$R_1 \cup R_2$ & $\sem{R_1}$s or $\sem{R_2}$s\\
$R_1 \cap R_2$ & $\sem{R_1}$s and $\sem{R_2}$s\\
$R_1 ; R_2$ & $\sem{R_1}$s something that $\sem{R_2}$s\\
$R^{-1}$    & is $\sem{R}$ed by\\
$R^*$       & $\sem{R}$s something that $\sem{R}$s something and so on that $\sem{R}$s\\
$\Delta_C$  & $\sem{C}$s and is the same as\\
\hline
Property of type $T$ & property phrase\\
$i$ & $lex(i)$\\
\end{tabular}
\caption{Interpretation Function for BOL into English (intransitive VP version)}\label{fig:bolsem:narrative1}
\end{figure}

\begin{example}
  Consider an ontology with declarations $\kw{individual}\; P$, $\kw{individual}\; M$, $\kw{relation}\; l$, $\kw{relation}\; h$ and a lexicon function $P\mapsto\text{Peter}, M\mapsto\text{Mary}, l\mapsto\text{love}$, then  $\sem{P\; l\; M}$ = ``Peter loves Mary''. 
\end{example}

\begin{example}
  If we extend the ontology above with $\kw{concept} d$ and $\kw{concept} c$ and the lexicon with $lex(d)=\text{is a dog}$ and $lex(c)=\text{is a cat}$, then $M\; \mathtt{is-a}\; c$ translates to ``Mary is a cat'', and  $P\; \mathtt{is-a}\; c\sqcap d$ translates to ``Peter is a cat or is a dog''.
\end{example}

But while the target languages in the other translations are formal languages engineered for regularity (see also the discussion in \Cref{sec:compositionality}) and simplicity (in terms of language primitives), while natural languages have evolved in practical human communication.
As a consequence, the translation in \Cref{fig:bolsem:narrative} results in English that is clumsy at best and non-grammatical in general.
We can think of this as \textbf{BOL-pidgin} English.

Let us have a look at some of the problems that appear in both translations:
\begin{itemize}
\item our lexicon does not have any inflection information and the translation tries to remedy that by appending ``s'' in various places. This works for the example above but not for relations that verbalize to ``has a'' or ``has as child''.
\item We have introduced some pattern matching and conditional rules in \Cref{fig:bolsem:narrative} to alleviate the greatest awkwardnesses, but much more would be needed, which would lead to things like ``Peter hass Mary'' or ``Peter has as childs Mary''. 
\item there are many linguistic devices that serve an important role in natural language, but which we are not tageting. An example is plural objects for aggregation. Say we have $P \mathtt{is-a} C$, $P \mathtt{is-a} C$, this would translate to ``Peter is a $\sem{C}$, Mary is a $\sem{C}$'' in BOL-pidgin, whereas in natural English would aggregate this to ``Peter and Mary are $\sem{C}$s''.
\end{itemize}

A way out here is to utilize special systems for dealing with the surface structure of natural language.
An example of this is the GF system (Grammatical Framework~\cite{Ranta:gfpmg11,GF:url}) which allows to specify a rich formal language \textbf{abstract syntax trees} (ASTs) together with language-specific \textbf{linearizations}, which amount to recursive functions that translate ASTs to language-specific strings.
GF comes with  a large resource library~\cite{GFResourceGrammar:url} that provides a comprehensive, language-independent AST specification and  linearlizations for over 35 languages.
We will not pursue this here, there is a special course ``Logic-based Natural Languge Semantics'' at FAU in the Winter Semesters that covers these and related topics.   

\subsection{Compositionality}\label{sec:compositionality}

\paragraph{Definition}
An interpretation function is compositional if the interpretation of any kind of expression $E(e_1,\ldots,e_n)$ with direct subexpressions $e_i$ only depends on $E$ and the interpretation of the $e_i$, i.e., \[\sem{E(e_1,\ldots,e_n)}=\sem{E}(\sem{e_1},\ldots,\sem{e_n})\] for some semantic operation $\sem{E}$.

The interpretations of BOL in FOL and SQL are compositional.
For example, consider the case of composition of relations:
 \[\sem{R_1 ; R_2}= \exists m:\iota.\ \sem{R_1}(x,m)\wedge \sem{R_2}(m,y)\]
We have $n=2$ and $E$ is the $;$-operator mapping $(e_1,e_2)\mapsto e_1;e_2$, i.e., $R_1$ and $R_2$ are the direct subexpressions of $R_1;R_2$.
The semantics is a relatively complicated FOL-formula, but it only depends on $\sem{R_1}$ and $\sem{R_2}$ --- everything else is fixed.
We have $\sem{;}=(p_1,p_2)\mapsto \exists m:\iota.\ p_1(x,m)\wedge p_2(m,y)$, i.e., the interpretation of the $;$-operator is the function that maps two predicates $p_1,p_2$ to the formula $\exists m:\iota.\ p_1(x,m)\wedge p_2(m,y)$.
Then we have \[\sem{R_1;R_2}=\sem{;}(\sem{R_1},\sem{R_2}).\]


It is highly desirable but not always possible to give a compositional translation.
Sometimes a feature of the syntactic language cannot be directly interpreted in the semantic language.
In that case, it may still be possible to give a non-compositional translation.

\begin{example}[Non-Compositional Translation via Sub-Induction]
A simple example of non-compositionality is the translation of natural numbers based on zero, one, and addition (i.e., $N\bbc 0\bnfalt 1\bnfalt N+N$) into natural numbers based on zero and successor (i.e., $N\bbc 0\bnfalt\cn{succ}(N)$):
It is straightforward to translate zero and one compositionally:
\[\sem{0}=0 \tb\sem{1}=\cn{succ}(0)\]
Now we would like to translate \[\sem{m+n}=\sem{+}(\sem{m},\sem{n}),\] but there is no way to define $\sem{+}$ in terms of zero and successor.
Instead, we need subcases:
\[\sem{m+n}=\cas{\sem{m}\mifc n=0 \\ \cn{succ}(\sem{m})\mifc n=1 \\ \sem{(m+n_1)+n_2}\mifc n=n_1+n_2}\]
This corresponds to the usually definition of addition, i.e., $\sem{+}$, by induction.
\end{example}

Other common examples of non-compositional translations are
\begin{compactitem}
 \item several important logical theorems such as
  \begin{compactitem}
   \item cut elimination, which is he translation from sequent calculus with cut to sequent calculus without cut,
   \item the deduction theorem, which is the translation from natural deduction to Hilbert calculus,
  \end{compactitem}
 \item almost anything done by an optimizing compiler, e.g., loop unrolling or function inlining,
 \item query optimization done by a database, e.g., turning a WHERE of a join into a join of WHEREs,
 \item almost all translations between natural languages, e.g., when words are ambiguous and a different translation must be chosen for the same word based on the context.
\end{compactitem}

Typical sources of non-compositionality in formal language translations are:
\begin{compactitem}
 \item A case in the translation function requires subcases which inspect the $e_i$ and treat them differently.
 \item A case in the translation function requires subcases which translate an expression differently based on the context in which it occurs.
 \item The translation function requires nested inductions, i.e., a case in the translation function (which is already inductive) requires a sub-induction on one of the sub-expressions.
 \item The semantic prefix is not fixed but depends on the translated object, i.e, the top-level case of the translation scans through the entire argument $X$ to collect all occurrences of a particular feature and then custom-builds the semantic prefix of $\sem{X}$.
\end{compactitem}

In Fig.~\ref{fig:bolsem}, we omitted the case for the transitive closure.
That was because it is not possible to translate it compositionally into FOL.
We can only do it non-compositionally with a custom semantic prefix:

\begin{example}[Non-Compositional Translation via Custom Semantic Prefix]
We define the FOL-interpretation of an ontology $O$ by $\sem{O}=P_O,\sem{O}$, where $P_O$ is a custom semantic prefix.
$P_O$ is different for every ontology $O$ and is defined as follows:

\begin{compactenum}
 \item We scan through $O$ and collect all occurrences of $R^*$ for any (not necessarily atomic) relation $R$.
 \item $P_O$ contains the following declarations for each $R$:
  \begin{compactitem}
  \item A binary predicate symbol $C_R\sq i\times i$. Note that $R$ may be a complex expression; so we have to generate a fresh name $C_R$ here.
  \item The axiom $\forall x:\iota,y:\iota.\ R(x,y)\impl C_R(x,y)$, i.e., $C_R$ extends $R$.
  \item The axiom $\forall x:\iota,y:\iota,z:\iota.\ C_R(x,y)\wedge C_R(y,z)\impl C_R(x,z)$, i.e., $C_R$ is transitive.
  \end{compactitem}
 \item We add the case $\sem{R^*}=C_R(x,y)$ to the interpretation function.
\end{compactenum}

Intuitively, every occurrence of the $^*$-operator is removed from the language and replaced with a fresh name that is axiomatized to have the needed properties.
All of these axioms are added to the semantic prefix.
\end{example}

Such non-compositional translations are undesirable for multiple reasons:
\begin{compactitem}
 \item The implementation is more complicated and error-prone.
 \item Reasoning about the translation is more difficult.
 \item The custom semantic prefix can be large.
\end{compactitem}

But most importantly, non-compositional translations are less robust.
Firstly, if we add a production to the syntax, a compositional translation is easy to extend: just add a case to the translation.
But a non-compositional translation may additionally require a new subcase wherever subcases/subinductions are used.
Moreover, if a custom semantic prefix is used, its definition may have to be amended, at least it must be rechecked.

Secondly, in practice there are two sources of complex expressions: the ones already mentioned in the language, and the ones used later for other reasons.
For example, in BOL some complex expressions occur already \emph{statically} in the definition of an ontology $O$.
But others might be appear \emph{dynamically} later, e.g., when talking about $O$, proving properties of $O$, or running queries on $O$.
Thus, the definition of $O$ and the use of complex expressions are decoupled: $O$ is defined statically once and for all, and complex expressions relative to $O$ can be created and used dynamically.
But if a custom semantic prefix is used, only the static occurrences inside $O$ can be considered for building the prefix.
Thus, it is not possible to translate the dynamic occurrences of the transitive closure unless the semantic prefix is extended all the time as $O$ is used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Representing Ontologies as Triples}

It is common to represent an entire ontology as a set of subject-predicate-object triples.
That makes handling ontologies very simple and efficient.
This is the preferred representation of the semantic web.

However, while, e.g., relation assertions are naturally triples, not all declarations are, and some tricks may be necessary.

\paragraph{Inferring the Entity Declarations}
The entity declarations are not naturally triples.
But we can usually infer them from the assertions as follows: any identifier that occurs in a position where an entity of a certain kind is expected is assumed to be declared as an entity for that kind.

For example, the individuals are what occurs as the subject of a concept, relation, or property assertion or as the object of a relation assertion.
It is conceivable that there are individuals that occur in none of these.
But that is unusual because they would be disconnected from everything in the ontology.

If we give TBox and ABox together, this inference approach usually works well.
But if we only give a TBox, this would often not allow inferring all entities.
The only place where they could occur in the TBox is in the axioms, and it is quite possible to have concept, relation, and property declarations that are not used in the axioms.
In fact, it is not unusual not to have any axioms.

\paragraph{Special Predicates}
To turn declarations into triples, we can use reflection, i.e., the process of talking about our language constructs as if they were data.

Reflection requires introducing some built-in entities that represent the features of the language.
In the semantic web area, this is performed using the following entities:
\begin{compactitem}
 \item "rdfs:Resource": a built-in concept of which all individuals are an instance and thus of which every concept is a subconcept
 \item "rdf:type": a special predicate that relates an entity to its type:
  \begin{compactitem}
   \item an individual to its concept (corresponding to \texttt{is-a} above)
   \item other entities to their special type (see below)
  \end{compactitem}
 \item "rdfs:Class": a special class to be used as the type of classes
 \item "rdf:Property": a special class to be used as the type of properties
 \item "rdfs:subClassOf": a special relation that relates a subconcept to a superconcept
% \item "rdfs:subPropertyOf": a special relation that relates a relation to one that it implies
 \item "rdfs:domain": a special relation that relates a relation to the concepts of its subjects
 \item "rdfs:range": a special relation that relates a relation/property to the concept/type of its objects
\end{compactitem}
Here "rdf" and "rdfs" refer to the RDF (Resource Description Framework) and RDFS (RDF Schema) namespaces, which correspond to W3C standards defining those special entities.

Thus, we can represent many and in particular the most important entity declarations as triples:
\begin{center}
\begin{tabular}{l|lll}
Assertion & \multicolumn{3}{c}{Triple} \\
          & Subject & Predicate & Object \\
\hline
individual & individual & "rdf:type" & "rdfs:Resource" \\
concept  & concept & "rdf:type" & "rdf:Class" \\
relation & relation & "rdf:type" & "rdf:Property" \\
property & property & "rdf:type" & "rdf:Property" \\
concept assertion  & individual & "rdf:type" & concept \\
relation assertion & individual & relation & individual \\
property assertion & individual & property & value \\
\hline
\multicolumn{4}{l}{for special forms of axioms}\\
$c\sqsubseteq d$ & $c$ & "rdfs:subClassOf" & $d$ \\
%$r\sqsubseteq s$ & $r$ & "rdfs:subPropertyOf" & s \\
$\dom\,r\Equiv c$ & $r$ & "rdfs:domain" & $c$ \\
$\rng\, r\Equiv c$ & $r$ & "rdfs:range" & $c$ \\
\end{tabular}
\end{center}

This is subject to the restriction that only atomic concepts and relations can be handled.
For example, only concept assertions can be handled that make an individual an instance of an \emph{atomic} concept.
This is particularly severe for axioms, where complex expressions occur most commonly in practice.
Here, the special relations allow capturing the most common axioms as triples.

\paragraph{Problems}
Reflection is subtle and can easily lead to inconsistencies.
We can see this in how the approach of RDF(S) special entities breaks the semantics via FOL.

For example, it treats classes both as concepts (when they occur as the object of a concept assertion) and as individuals (when they occur as subject or object of a "rdfs:subClassOf" relation assertion).
Similarly, "rdfs:Class" is used both as an individual and as a class.
In fact, the standard prescribes that "rdfs:Class" is an instance of itself.

In practice, this is handled pragmatically by using ontologies that make sense.
A formal way to disentangle this is to assume that there are two variants of "rdfs:Class", one as an individual and one as a class.
The translation must then translate "rdfs:Class" differently depending on how it is used.

It would be better if RDFS were described in a way that is consistent under the implicitly intended FOL semantics.
But the more pragmatic approach has the advantage of being more flexible.
For example, being able to treat every class, relation, or property also as an individual makes it easy to annotate metadata to them.
Metadata is a set of properties such as "rdfs:seeAlso" or "owl:versionInfo", whose subjects can be any entity.


\paragraph{Subject-Centered Representations}
When giving a set of triples, there are usually a lot of triples with the same subject.
For example, we could use a simple concrete syntax with one triple per line and whitespace separating subject, predicate, and object:
\begin{lstlisting}
"Florian Rabe" is-a "Instructor"
"Florian Rabe" is-a "male"
"Florian Rabe" "teaches" "WuV"
"Florian Rabe" "teaches" "KRMT"
"Florian Rabe" "age" 40
"Florian Rabe" "office" "11.137"
\end{lstlisting}

It is more human-friendly to group these triples in such a way that the subject only has to be listed once.
For example, we could use a concrete syntax like this, where the subject occurs first and then predicate-object pairs occur on indented lines:
\begin{lstlisting}
"Florian Rabe"
  is-a "Instructor"
  is-a "male"
  "teaches" "WuV"
  "teaches" "KRMT"
  "age" 40
  "office" "11.137"
\end{lstlisting}

If the same predicate occurs with multiple values, we can group those as well.
For example, we could give the objects for the same predicates as a list following the predicate:
\begin{lstlisting}
"Florian Rabe"
  is-a "Instructor" "male"
  "teaches" "WuV" "KRMT"
  "age" 40
  "office" "11.137"
\end{lstlisting}

Concrete syntaxes based on the triple representation of ontologies will usually adopt some kind of structure like this.
The details may vary.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type Systems for Ontologies}

\subsection{Concepts as Types}


\subsection{Record Types}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "WuV_notes"
%%% mode: visual-line
%%% fill-column: 5000
%%% End:

%  LocalWords:  ontologization sqsubseteq commgrammar gcomment gprod galtprod Equiv sqcup sqcap relativization rng itg strg fig:bolsem sq impl x,y y,x iota,y m,y doteq fig:bolsemsql medskip Kohlhase:ulsmf08 Compositionality sec:compositionality bnfalt bnfalt bnfalt succ mifc mifc mifc iota,z y,z x,x subinductions rdfs:Resource rdf:type rdfs:Class rdf:Property rdfs:subClassOf rdfs:subPropertyOf rdfs:domain rdfs:range rdf rdfs Subject-Centered childs Ranta:gfpmg11,GF:url linearizations
