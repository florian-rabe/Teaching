\section{Formal Systems}

\begin{frame}\frametitle{Typical Structure of a Formal System}
Vocabularies
\begin{itemize}
\item lists of declarations
\end{itemize}

Declarations
\begin{itemize}
\item named
\item at least one for each expression kind
\item may contain other expressions \glec{e.g., type, definition}
\item may contain nested declarations \glec{e.g., fields in an ADT}
\end{itemize}

Expressions
\begin{itemize}
\item inductive data type
\item relative to vocabulary \glec{names occur as base cases}
\item formulas as special case
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: Vocabularies and Expressions}
\begin{center}
\footnotesize
\begin{tabular}{l|ll}
Aspect & vocabulary $\Theta$ & expression kinds \\
\hline
Ontologization  & ontology & individual, concept, relation, property, formula \\
Concretization & database schema & cell, row, table, formula \\
Computation & program & term, type, object, class, \ldots \\
Logic & signature, theory & term, type, formula, \ldots \\
Narration & dictionary & phrases, sentences, texts \\
\end{tabular}
\end{center}
\end{frame}

%\begin{frame}\frametitle{Examples}
%See notes made during the lecture for examples
%\end{frame}

\begin{frame}\frametitle{Components and Well-Formedness}
\begin{blockitems}{Components of formal system $l$}
 \item context-free syntax
 \item distinguished non-terminal symbol $\ThySym$ \glec{words called \textbf{vocabularies}}
 \item some distinguished non-terminal symbols \glec{words called \textbf{expressions}}
 \item unary predicate $\wft{V}$ on vocabularies $V$ \glec{well-formed vocabulary $V$}
 \item unary predicates $\wff{V}{e}$ \glec{well-formed expressions $e$}
\end{blockitems}

\begin{blockitems}{Intuition}
\item context-\emph{free} syntax generates more than needed
\item context-\emph{sensitive} well-formedness defines the exact subset
\end{blockitems}

Question: How do we define the well-formedness predicates?
\lec{use an inference system with context-sensitive rules}
\end{frame}

\begin{frame}\frametitle{Inference System}
\begin{blockitems}{Define well-formedness via type system}
\item contexts $\Gamma$ of the form $x_1:E_1,\ldots,x_n:E_n$ for expressions $E_i$
\item a set of judgments including
 \begin{itemize}
  \item a judgment $\vdash^l V$ on vocabularies $V$
  \glec{$\wft{V} \;\miff\; \vdash^l_V$}
  \item a judgment $\Gamma\vdash^l_V e:E$ between expressions $e,E$
  \glec{$\wff{V}{e}\;\miff\; \vdash^l_V e:E \mforsome E$} 
 \end{itemize}
\item a set of rules for the judgments, each one of the form
\[\rul{J_1 \tb \ldots \tb J_n}{J}\]
where the $J$'s are judgments
\end{blockitems}
\glec{conventions: leave out superscript $l$, subscript $V$ if clear}
\glec{leave out $\Gamma$ if empty}
\end{frame}

\begin{frame}\frametitle{Terminology}
For an inference system, we define
\begin{itemize}
\item derivation: tree of judgments such that for every node $J$ with children $J_1,\ldots,J_n$, there is a rule
\[\rul{J_1 \tb \ldots \tb J_n}{J}\]
\item derivation of $J$: a derivation with root $J$
\item $J$ holds: there is a derivation of $J$
\end{itemize}
\[\Voc^l = \{V\,|\,\vdash^l V\}\]
\[\Exp^l_V(E) = \{e\,|\,\vdash^l_V e:E\}\]
\[\Exp^l_V = \bigcup_E \Exp^l_V(E)\]
\end{frame}

\begin{frame}\frametitle{Special Cases}
\begin{blockitems}{A formal system with propositions}
\item additionally has a distinguished expression $\prop$
\item define $F$ is proposition if $\vdash_V F:\prop$
\end{blockitems}

\begin{blockitems}{A formal system with equality}
\item additionally has a distinguished proposition $e_1\doteq_E e_2$ whenever $\vdash e_i:E$
\end{blockitems}
\glec{in the sequel: fix $l$ as above}
\end{frame}

\section{Deductive Semantics}

\begin{frame}\frametitle{Deductive Semantics}
\begin{blockitems}{Definition}
\item a system that determines which propositions are theorems
\item for every $V$, a subset $\Thm^l_V\sq \Exp^l_V(\prop)$ of theorems
 \glec{write $\vdash^l_V F$ for $F\in\Thm^l_V$}
\end{blockitems}

\begin{blockitems}{Terminology}
\item Logic: language plus deductive semantics
\item Calculus: set of rules defining absolute deductive semantics
\item Theorem prover: implementation of deductive semantics
\item Decision procedure: special case of theorem prover when decidable
\end{blockitems}

\begin{blockitems}{Examples}
\item Natural deduction for first-order logic
\item Axiomatic set theory for (most of) mathematics
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Redundant Deductive Semantics}
\begin{blockitems}{Multiple deductive semantics}
\item Proof theory: absolute
\item Model theory: relative via translation to set theory $L$
 \glec{write $\models F$ for $\vdash_L \truelift\sem{F}$}
\item Logic translation: relative via translation into standard logics, e.g., SFOL
\end{blockitems}

\begin{blockitems}{Equivalence Theorems}
\item Soundness: $\vdash F$ implies $\models F$
\item Completeness: $\models F$ implies $\vdash F$
\glec{accordingly for other translations}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Relationship to Typing}
Define deductive semantics as a special case of typing
\begin{itemize}
\item propositions as types
\item proofs as expressions
\item extend grammar so that there are expressions for proofs
\item add typing rules such that $\vdash P:F$ captures the statement ``$P$ is proof of $F$''
\item define: $\vdash F$ iff there is $P$ such that $\vdash P:F$
\end{itemize}
\lec{often called Curry-Howard representation}
\end{frame}

\section{Computational Semantics}

\begin{frame}\frametitle{Computational Semantics}
\begin{blockitems}{Definition}
\item determines how expressions evaluate to values
\item for every $V$, a function $\Eval^l_V:\Exp^l_V\to\Exp^l_V$
\glec{write $\vdash^l_V e\rewrites e'$ for $e'=\Eval^l_V(e)$}
\end{blockitems}

\begin{blockitems}{Terminology}
\item Programming language: languages plus computational semantics
\item Operational semantics: rules defining computational semantics
\item Interpreter: implementation of absolute semantics
\item Compiler: implementation of relative semantics
\end{blockitems}

\begin{blockitems}{Examples}
\item Any interpreted language \glec{Python, bash, \ldots}
\item Machine language \glec{interpretation rules built into microchips}
\end{blockitems}
\end{frame}

\begin{frame}{Caveat}
Evaluation $\vdash^l_V e\rewrites e'$ insufficient in general
\glec{special case of interpreter when evaluation pure and terminating}

Actual programming languages more complex
\begin{itemize}
\item IO channels
\item Object creation/destruction
\item Mutable variables
\item Non-termination (needed for Turing completeness)
\end{itemize}
\glec{Semantics requires environment, heap, stack, references, \ldots}
\end{frame}

\begin{frame}\frametitle{Redundant Computational Semantics}
\begin{blockitems}{Multiple computational semantics}
\item Specification: absolute as rules on paper
\item Interpreter: absolute as implementation
\item Compiler: relative via translation to assembly $L$
 \glec{write $\models E\rewrites V$ for $\vdash_L \sem{E}\rewrites \sem{V}$}
\item Cross-compilation: relative via translation into other languages
 \glec{Church-Turing thesis: always possible}
\end{blockitems}

\begin{blockitems}{Equivalence Theorems}
\item Correctness of compiler: $\vdash E\rewrites V$ iff $\models E\rewrites V$
\glec{accordingly for other translations}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Relationships to other judgments}
\begin{blockitems}{Big Step vs. Small Step}
 \item big step: $\vdash^l_V e\rewrites e'$ is the entire evaluation
 \item small step: $\vdash^l_V e\rewrites e'$ is just one step and semantics requires exhaustive chaining of steps
\end{blockitems}

\begin{blockitems}{Typing}
 \item subject reduction: if $\vdash e:E$, then $\vdash \Eval(e):E$
\end{blockitems}

\begin{blockitems}{Deductive semantics with equality}
 \item normal forms:
  \begin{itemize}
  \item $\Eval^l_V$ idempotent, i.e., $\Eval^l_V(x)=x$ if $x$ value
  \item $\vdash^l_V e\doteq_E\Eval^l_V(e)$
  \end{itemize} 
 \item canonical forms: $\vdash^l_V e_1\doteq_E e_2$ iff $\Eval^l_V(e_1)=\Eval^l_V(e_2)$
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Interdefinability}
\begin{blockitems}{Given a computational semantics, define a deductive one:}
\item distinguished expression $\vdash \true:\prop$,
\item $\vdash F$ iff $\Eval(F)=\true$
\lec{implies decidability, so usually only possible for some $F$}
\end{blockitems}

\begin{blockitems}{Given a deductive semantics, define computational one:}
\item $\Eval(e)$ is some $e'$ such that $\vdash e\doteq e'$
\lec{trivially normal, but usually not canonical}
\end{blockitems}

Both kinds of semantics add different value. We usually want both.
\end{frame}

\section{Contexts and Substitutions}

\begin{frame}\frametitle{Syntax with Contexts}
If we want to talk about contexts, too, we need to expand all of the above.

\begin{blockitems}{Syntax with contexts}
\item contexts: for every $V$, a set $\Cont^l_V$
 \glec{write $\vdash_V \Gamma$}
\item substitutions: for $\Gamma,\Delta\in\Cont_V$, a set $\Subs_V(\Gamma,\Delta)$
 \glec{write $\vdash_V \gamma:\Gamma\to\Delta$}
\end{blockitems}

\begin{blockitems}{Expressions in context}
\item expressions: sets $\Exp_V(\Gamma)$
\item substitution application: functions $\Exp(\gamma):\Exp(\Gamma)\to\Exp(\Delta)$ for $\gamma\in\Subs(\Gamma,\Delta)$
\glec{write $\Exp(\gamma)(e)$ as $e[\gamma]$}
\end{blockitems}

\begin{blockitems}{Typing in context}
\item expressions: sets $\Exp_V(\Gamma,E)$, written as $\Gamma\vdash_V e: E$
\item substitution preserves types: if $\Gamma\vdash e:E$ and $\vdash \gamma:\Gamma\to\Delta$, then $\Delta\vdash e[\gamma]:E[\gamma]$
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Contexts: General Definition}
We can leave contexts abstract or spell out a concrete definition:
\begin{itemize}
\item contexts $\Gamma$ are of the form \[x_1:E_1,\ldots,x_n:E_n\]
 where $E_i\in\Exp(x_1:E_1,\ldots,x_{i-1}:E_{i-1})$
\item for $\Gamma$ as above, substitutions $\Gamma\to \Delta$ are of the form: \[x_1=e_1,\ldots,x_n=e_n\]
 where $\Delta\vdash e_i: E_i[x_1=e_1,\ldots,x_{i-1}=e_{i-1}]$
\end{itemize}
\medskip

This works uniformly for any formal system.
But most formal systems are a bit more restrictive, e.g., by requiring that all $E_i$ are types.
\end{frame}

\begin{frame}\frametitle{Semantics with Contexts}
\begin{blockitems}{Deductive semantics}
\item define: theorem sets $\Thm_V(\Gamma)$
 \glec{write $F\in\Thm_V(\Gamma)$ as $\Gamma\vdash_V F$}
\item such that theorems are preserved by substitution: \\
 if $\Gamma\vdash_V F$ and $\vdash \gamma:\Gamma\to\Delta$, then $\Delta\vdash_V F[\gamma]$
\end{blockitems}

\begin{blockitems}{Computational semantics}
\item define: evaluation functions $\Eval_V(\Gamma):\Exp_V(\Gamma)\to\Exp_V(\Gamma)$
  \glec{write $e'=\Eval_V(\Gamma)(e)$ as $\Gamma\vdash_V e\rewrites e'$}
\item extend to substitutions: $\Eval_V(\Delta)(\ldots,x=e,\ldots)\;=\;\ldots,x=\Eval_V(\Delta)(e), \ldots$
\item require that evaluation is preserved by substitution $\vdash \gamma:\Gamma\to\Delta$ \\
  $\Eval_V(\Delta)(e[\gamma])=\Eval_V(\Delta)(e)[\Eval_V(\Delta)(\gamma)]$
\glec{substitution theorem for $\Eval$ as a translation from $l$ to itself}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Definitions for Substitutions}
\begin{itemize}
\item write $\cdot$ for empty context/substitution
\item ground expression is expression in empty context
 \glec{also called closed; then opposite is open}
\item ground substitution: $\vdash \gamma:\Gamma\to \cdot$
 \glec{no free variables after substitution}
\item if we have computational semantics: \\ value substitution is ground substitution where all expressions are values
\item if we have deductive semantics: \\
 true instance of $\Gamma\vdash F:\prop$ is $\gamma$ such that $\vdash F[\gamma]$
\end{itemize}
\end{frame}

\section{Concrete Semantics}

\begin{frame}\frametitle{Concrete Semantics}
\begin{blockitems}{Definition}
\item determines the true instances of propositions
\item for every $\Gamma\vdash^l_V F:\prop$, a set $\Inst^l_V(\Gamma,F)$ of ground substitutions
 \glec{write $\vdash^l_V\gamma:\Gamma$ and $\vdash F[\gamma]$ for $\gamma\in\Inst_V(\Gamma,F)$}
\end{blockitems}

\begin{blockitems}{Terminology}
\item Query languages (in the usual, narrower sense than used here): languages plus concrete semantics
\item Database: implementation of concrete semantics
 \lec{usually optimized for fast query answering}
\end{blockitems}

\begin{blockitems}{Examples}
\item SQL for Church-typed ontologies with ADTs (relational databases)
\item SPARQL for Curry-typed ontologies (triple stores)
\item Prolog for first-order logic
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Yes/No vs. Wh-Questions}
Deductive/concrete semantics may be a bit of a misnomer
\begin{itemize}
\item Queries about $\vdash F$ are yes/no questions
 \begin{itemize}
 \item specialty of deductive semantics
 \item but maybe only because everything else is ever harder to do deductively
 \end{itemize}
\item Queries about ground instances of $\Gamma \vdash F$ are Wh questions
 \begin{itemize}
 \item specialty of concrete databases
 \item for the special case of retrieving finite results sets from a fixed concrete store
 \item only situation where Wh questions are easy
 \end{itemize}
\end{itemize}
But Yes/no and Wh questions exist in all aspects.
\end{frame}

\begin{frame}\frametitle{Redundant Concrete Semantics}
\begin{blockitems}{Multiple concrete semantics}
\item Specification: absolute as rules on paper
\item Database: absolute by custom database
\item Database: relative via translation to assembly $L$
\end{blockitems}

\begin{blockitems}{Equivalence Theorems}
\item typically: choose one, no redundancy, no equivalence theorems
\item infinite results: easy on paper, hard in database
\item open world: are all known ground instances in database?
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Interdefinability}
\begin{blockitems}{Given concrete semantics, define a deductive one}
\item for ground $F$, $\Inst(\cdot,F)$ is either $\{\cdot\}$ or $\{\}$
\item $\vdash F$ iff $\Inst(\cdot, F)=\{\cdot\}$
\lec{but concrete semantics usually cannot find all substitutions for all $F$}
\end{blockitems}

\begin{blockitems}{Given concrete semantics, define a computational one}
\item $\vdash e\rewrites e'$ iff $(x=e')\in\Inst(x:E, e\doteq_E x)$
\lec{but concrete semantics usually cannot find that substitution for all $e$}
\end{blockitems}

\begin{blockitems}{Given deductive semantics, define a concrete one}
\item $\Inst(\Gamma,F)=\{\vdash \gamma:\Gamma\to\cdot \;|\;\vdash F[\gamma]\}$
\lec{but deductive semantics usually does not allow computing that set}
\end{blockitems}

\begin{blockitems}{Given computational semantics, define a concrete one}
\item $\Inst(\Gamma,F)=\{\Eval(\cdot,\gamma) \;|\;\vdash \gamma:\Gamma\to\cdot, \;\vdash F[\gamma]\rewrites \true\}$
\item allows restricting results to value substitutions
\lec{composition of previous inter-definitions, inherits both problems}
\end{blockitems}
\end{frame}

\section{Narrative Semantics}

\begin{frame}\frametitle{Narrative Semantics}
\begin{blockitems}{Definition}
\item Describes how to answer (some) questions
\item Implementations tend to be AI-complete, hypothetical
\item In practice, information retrieval = find related documents
\end{blockitems}

\begin{blockitems}{More precisely?}
\item Not much theory, wide open research problem
\item Some natural language document with interspersed definitions, formulas
\item Maybe judgment: $\vdash Q ? A$ for ``$A$ is answer to $Q$''
\end{blockitems}

\begin{blockitems}{Examples}
\item ``W3C Recommendation OWL 2'' and Google
\item ``ISO/IEC 14882: 1998 Programming Language C++'' and Stroustrup's book
\item Mathematics textbooks and mathematicians
\end{blockitems}
\end{frame}

%\begin{frame}\frametitle{Abstract vs. Concrete Semantics}
%\begin{blockitems}{Abstract}
%\item $\Exp$, $\Thm$, $\Eval$ just assumed as sets/functions
%\item No requirement how they are constructed
% \begin{itemize}
% \item inductive structure of expressions optional
% \item both absolute and relative semantics are special cases
%\end{itemize}
%\end{blockitems}
%
%\begin{blockitems}{Concrete, e.g.,}
%\item $\Exp_V$ defined by grammar
%\item rule system defined by
% \begin{itemize}
% \item calculus for $\vdash_V e:E$
% \item alternatively: trivial type system where \\
%  all non-terminals $N$ are expressions too \\
%  and $\vdash E:N$ iff $E$ derived from $N$
% \end{itemize}
%\item $\Thm_V$ defined by calculus for $\vdash_V F$
%\item $\Eval_V$ defined by calculus for $\vdash_V e \rewrites e'$
%\end{blockitems}
%\end{frame}

\section{Relative Semantics}

\begin{frame}\frametitle{Translations}
\begin{blockitems}{A translation $T$ from formal system $l$ to formal system $L$ consists of}
\item function $\Voc^T:\Voc^l\to\Voc^L$
\item family of functions $\Exp^T_V:\Exp^l_V\to\Exp^L_{\Voc^T(V)}$
\end{blockitems}

\begin{blockitems}{Desirable properties}
\item Should satisfy type preservation:
\[\vdash^l_V e:E \tb\mimplies\tb \vdash^L_{\Voc^T(V)} \Exp^T_V(e):\Exp^T_V(E)\]
\lec{intuition: what we have, is preserved}
\item Might satisfy type reflection/conservativity: 
\[\vdash^L_{\Voc^T(V)} e':\Exp^T_V(E) \tb\mimplies\tb \vdash^l_V e:E \mforsome e\]
\lec{intuition: nothing new is added}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Translation of Contexts}
\begin{blockitems}{Translations extend to contexts and substitutions}
 \item $\Cont^T(\ldots,x:E,\ldots) \;=\;\ldots, x:\Exp^T(E), \ldots$
 \item $\Subs^T(\ldots,x=e,\ldots) \;=\;\ldots, x=\Exp^T(e), \ldots$
 \item $\Exp^T(x)=x$ for all variables
\end{blockitems}

\begin{blockitems}{Desirable properties for arbitrary contexts}
\item Type preservation:
\[\Gamma\vdash^l_V e:E \tb\mimplies\tb \Cont^T_V(\Gamma)\vdash^L_{\Voc^T(V)} \Exp^T_V(e):\Exp^T_V(E)\]
\item Conservativity:
\[\Cont^T_V(\Gamma)\vdash^L_{\Voc^T(V)} e':\Exp^T_V(E) \tb\mimplies\tb \Gamma\vdash^l_V e:E \mforsome e\]
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Compositionality}
Define: a translation is compositional iff we can show the substitution theorem for it

Given
\[\Gamma\vdash^l_V e:E \tb\vdash^l_V \gamma:\Gamma\to\Delta\]
we have that
\[\Cont^T_V(\Delta)\vdash^L_{\Voc^T(V)}\Exp^T_V(e[\gamma])\doteq_{\Exp^T_V(E[\gamma])}\Exp^T_V(e)[\Subs^T_V(\gamma)] \]

Simplify: write
$T(-)$ for $\Voc^T(-), \Exp_V^T(-)$, $\Cont_V^T(-)$, $\Subs_V^T(-)$
\[T(\Delta)\vdash^L_{T(V)}T(e[\gamma])\doteq_{T(E[\gamma])}T(e)[T(\gamma)] \]
\end{frame}

\begin{frame}\frametitle{Relative Semantics}
Given
 \begin{itemize}
 \item formal systems $l$ and $L$
 \item semantics for $L$
 \item translation $T$ from $l$ to $L$
 \end{itemize}
define semantics for $l$
\medskip

\begin{itemize}
\item deductive: define
 \[\vdash^l_V F \tb\miff\tb \vdash^L_{\Voc^T(V)} \Exp^T_V(F) \]
\item computational: define
 \[\vdash^l_V e\rewrites e' \tb\miff\tb \vdash^L_{\Voc^T(V)}\Exp^T_V(e)\rewrites \Exp^T_V(e')\]
\glec{both work accordingly with a context $\Gamma$}
\item concrete: define
 \[\Gamma\vdash^l_V \gamma:F \tb\miff\tb \Cont^T_V(\Gamma)\vdash^L_{\Voc^T(V)}\Subs^T_V(\gamma):\Exp^T_V(F)\]
\end{itemize}
\end{frame}


\section{Equivalence of Semantics}

\begin{frame}\frametitle{Definition}
Two semantics $\vdash^1$ and $\vdash^2$ for $l$ are equivalent if
\begin{itemize}
\item deductive: $\vdash^1 F$ iff $\vdash^2 F$
\item computational: $\vdash^1 e\rewrites e'$ iff $\vdash^2 e\rewrites e'$
\item concrete: $\Gamma\vdash^1 \gamma:F$ iff $\Gamma\vdash^2 \gamma:F$
\end{itemize}

Example for deductive semantics:
\begin{itemize}
\item $\vdash^1$ absolute semantics by calculus \\
 e.g., natural deduction for SFOL
\item $\vdash^2$ relatives semantics by translation
 e.g., $L$ is set theory, $T$ is model theory of SFOL
\item Assume proofs-as-expressions
\item Then:
 \begin{itemize}
 \item type preservation = soundness
 \item conservativity = completeness
 \end{itemize}
\end{itemize}
\end{frame}

% \begin{frame}\frametitle{Exercise 6: Relative Deductive Semantics for BOL}
% \begin{itemize}
% \item Implement a translation from BOL to untyped FOL
 % \glec{you can drop properties, types, and values}
 % \glec{so that only one type of individuals is needed}
% \item Use TPTP syntax for FOL
 % \glec{see \url{http://www.tptp.org/}}
% \item Translate an example ontology
  % \glec{pick any ontology with a non-trivial consequence closure}
% \item Use a theorem prover for first-order logic to implement a relative deductive semantics for BOL
  % \glec{Vampire and E are standard choices}
  % \glec{see also \url{http://www.tptp.org/cgi-bin/SystemOnTPTP}}
% \item Test by example whether your semantics yields the correct consequence closure
% \end{itemize}
% \end{frame}

\begin{frame}\frametitle{Example: Relative Computational Semantics for BOL}
Scala, SQL semantics evaluates
\begin{itemize}
\item concept $c$ to
\begin{itemize}
\item SQL: table of individuals
 \lec{result of running query $\sem{c}$}
\item Scala: hashset of individuals
 \lec{result of running program $\sem{c}$}
\end{itemize}
\item propositions to booleans \lec{accordingly}
\end{itemize}

Technically, results not in image of $\sem{-}$\\
Fix: add productions for all values
\begin{commgrammar}
\gprod{F}{\true\bnfalt \false}{truth values}\\
\gprod{C}{\{I,\ldots,I\}}{finite concepts}
\end{commgrammar}
\end{frame}

\begin{frame}\frametitle{Equivalence with respect to Semantics}
So far: equivalence of \emph{two semantics} wrt \emph{all queries}

Related concept: equivalence of \emph{two queries} wrt \emph{one semantics}
\begin{itemize}
\item $F$, $G$ deductively equivalence: \[\vdash F \tb\miff\tb \vdash G\]
\glec{may be internalized by syntax as proposition $F\equiv G$}
\item $F,G$ concretely equivalent: \[\vdash F[\gamma] \tb\miff\tb \vdash G[\gamma]\] for all ground substitutions $\gamma$
\glec{weaker than $\Gamma\vdash F\equiv G$}
\item closed $e,e'$ computationally equivalent: \[\vdash e\rewrites v \tb\miff\tb \vdash e'\rewrites v\]
\glec{may be internalized by syntax as proposition $e\doteq e'$}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Equivalence with respect to Semantics (2)}
Interesting variants of computational semantics
\begin{itemize}
\item open $e,e'$ extensionally equivalent:
  \[\vdash e[\gamma]\rewrites v \tb\miff\tb \vdash e'[\gamma]\rewrites v\]
  for all ground substitutions $\gamma$
 \lec{equal inputs produce equal outputs}
 \glec{weaker then $\Gamma\vdash e\doteq e'$ --- intensional equivalence}
\item machines $M,M'$ observationally equivalent: \\
  produce equal sequences of outputs for the same sequence of inputs
  \glec{e.g., automata, objects in OO-programming}
\end{itemize}

\lec{choice of semantics defines legal optimizations in compiler}
\end{frame}

\begin{frame}\frametitle{Equivalence of BOL Semantics}
Now $5$ semantics for BOL
\begin{itemize}
\item absolute deductive via calculus
\item relative deductive via SFOL
\item relative computational via Scala
\item relative concrete via SQL
\item relative narrative via English
\end{itemize}
Moreover, these are interdefinable.
\glec{e.g., Scala translation also induces deductive semantics}

Can compare equivalence
\begin{itemize}
\item for every pair of semantics
\item for every kind of equivalence (deductive, concrete, computational)
\end{itemize}
Question: Which of them hold?
\end{frame}

\begin{frame}\frametitle{Questions}
For example, consider:
\begin{itemize}
\item Are the absolute semantics and the Scala semantics deductively equivalent?
\item Assuming BOL and SQL have the base types and values:
Are the absolute semantics and the SQL semantics concretely equivalent?
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Deductive Semantics of BOL}
Are these two BOL semantics deductively equivalent
\begin{itemize}
\item absolute deductive semantics 
\item relative deductive semantics via translation $\sem{-}$ to SFOL
\end{itemize}

\only<1>{
Soundness: $\vdash^{BOL}_V f$ implies $\vdash^{SFOL}_{\sem{V}}\sem{f}$ \\
 \begin{itemize}
 \item induction on derivations of $\vdash^{BOL}_V f$
 \item one case per rule
    \glec{induction rule from above not sound}
 \item several pages of work but straightforward and relatively easy
 \end{itemize}
}
\only<2>{
Completeness: $\vdash^{BOL}_V f$ implied by $\vdash^{SFOL}_{\sem{V}}\sem{f}$
 \glec{works if we add missing rules}
\begin{itemize}
\item induction on SFOL derivations does not work
 \begin{itemize}
 \item SFOL more expressive than BOL
 \item $\sem{-}$ not surjective
 \end{itemize}
\item instead show that $\sem{-}$ preserves consistency of vocabularies
 \glec{no universal recipe how to do that}
\item then a typical proof uses $V$ extended with $\neg f$
 \begin{itemize}
 \item if $V$ inconsistent, $\vdash_V f$ for all $f$, done
 \item if $V$ consistent and $V+\neg f$ inconsistent, then $\vdash_V f$, done
 \item if $V+\neg f$ consistent, so is $\sem{V+\neg f}$, which contradicts $\vdash^{SFOL}_{\sem{V}}\sem{f}$
 \end{itemize}
\end{itemize}
}
\end{frame}

\begin{frame}\frametitle{Computational Semantics of BOL}
Are these two BOL semantics deductively equivalent
\begin{itemize}
\item absolute deductive semantics 
\item relative deductive semantics via translation $\sem{-}$ to Scala
\end{itemize}

\only<1>{
Soundness: $\vdash^{BOL}_V f$ implies $\vdash^{Scala}_{\sem{V}}\sem{f}\rewrites \true$
\begin{itemize}
\item Problem: Absolute semantics performs consequence closure, e.g.,
\begin{itemize}
\item transitivity of $\sqsubseteq$
\item relationship between $\sqsubseteq$ and $\isa$
\end{itemize}
\item Scala semantics does so only if we explicitly implemented it
\glec{we didn't}
\glec{same problem for SQL semantics}
\end{itemize}
}

\only<2>{
Completness: $\vdash^{BOL}_V f$ implied by $\vdash^{Scala}_{\sem{V}}\sem{f}\rewrites \true$
\begin{itemize}
 \item absolute semantics leaves closed world optional
 \item Scala uses closed worlds
  \glec{e.g., used to compute $c\sqsubseteq d$ by checking all individuals} 
 \item complete only if we add induction rule
\end{itemize}
}
\end{frame}

\section{Vocabulary Morphisms}

\begin{frame}\frametitle{Idea}
Intuition of morphism $m$
\begin{itemize}
\item connects two vocabularies, written $m:V\to W$
\item maps $V$-symbols to $W$-expressions
\item extends homomorphically to ma $V$-expressions to $W$-expressions
 \glec{replace every symbol with its assignment}
 \glec{like substitutions for contexts}
\end{itemize}

Purpose
\begin{itemize}
\item extend $V$ with entirely new declarations \\
  special case of $W=V,E$, and maps like identity
\item extend the vocabulary with definitions \\
   special case $m:V,E\to V$, and $m$ new symbols to definitions
\item vocabulary evolution: $V$ is old vocabulary, $W$ new, $m$ interprets $V$ in $W$
\item transfer legacy content from old to new vocabulary
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: The Common Sense Ontology}
Situation:
\begin{itemize}
\item society uses one ontology for common sense knowledge
\item changes over time
\end{itemize}

Special aspects:
\begin{itemize}
\item unwritten
\item not actually fully agreed upon
\item sometimes subject to political debate
\item no formal ontology language good enough to capture practical nuances
\item many society members not comfortable with formal languages
\end{itemize}

\lec{but still always exists implicitly}

Idea: see political proposals as ontology evolution
\end{frame}

\begin{frame}[fragile]\frametitle{Example: Ontology Change}
Assume $V$ is BOL vocabulary containing
\begin{itemize}
\item concepts $\cn{man}$, $\cn{woman}$
\item axioms $\cn{man}\sqcup\cn{woman}\equiv \top$ and $\cn{man}\sqcap\cn{woman}\equiv \bot$
\end{itemize}
\glec{simplified cis-normative worldview}

and $W$ contains
\begin{itemize}
\item concepts $\cn{sexmale}$, $\cn{sexfemale}$, $\cn{cis}$, $\cn{trans}$
\item appropriate axioms
\end{itemize}
\glec{one possible proposal to accommodate transgender people}

Now ontology evolution from $V$ to $W$
\begin{itemize}
\item legacy content = any law, policy etc. referring to $V$-concepts
\item morphism $\cn{gendermatters}$
 \begin{itemize}
 \item $\cn{man}\mapsto (\cn{sexmale}\sqcap\cn{cis})\sqcup (\cn{sexfemale}\sqcap\cn{trans})$
 \item $\cn{woman}\mapsto (\cn{sexfemale}\sqcap\cn{cis})\sqcup (\cn{sexmale}\sqcap\cn{trans})$
 \end{itemize}
\item alternative morphism $\cn{sexmatters}$
 \begin{itemize}
 \item $\cn{man}\mapsto \cn{sexmale}$
 \item $\cn{woman}\mapsto \cn{sexfemale}$
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Side Note: Knowledge Representation is Apolitical}
Knowledge representation makes no judgment about which ontologies or morphisms are fair, moral, politically correct, etc.

It can only make judgments about whether an ontology (morphism) is practical, e.g., based on
\begin{itemize}
\item well-typedness and consistency of a vocabulary
\item decidability, efficiency of querying
\item simplicity, e.g., measured by
\begin{itemize}
\item number of declarations or the size of expressions
\item number of axioms about each symbol
\end{itemize}
\item existence and simplicity of morphisms
\end{itemize}

Languages must allow for expressing whichever knowledge or opinion the user has.
Users have to judge if an ontology or morphisms is the right one.
\end{frame}

\begin{frame}\frametitle{BOL Morphisms}
Syntax: Extend grammar with vocabulary morphisms
\begin{commgrammar}
\gprod{M}{\rep{A}: O\to O}{morphisms}\\
\gprod{A}{\ID\mapsto I}{individual assignment}\\
\galtprod{\ID\mapsto C}{concept assignment}\\
\galtprod{\ID\mapsto R}{relation assignment}\\
\galtprod{\ID \mapsto P}{property assignment}
\end{commgrammar}

Well-formedness for $M:O\to O'$:
\begin{itemize}
\item one assignment $\ID\mapsto E$ for each declaration $\ID$ of $O$
\item $E$ must be an $O'$-expression of the right type
 \begin{itemize}
 \item individual symbols to individual expressions
 \item concept symbols to concept expressions
 \item relation symbols to relation expressions
 \item property symbols of type $V$ to property expressions of type $V$
 \item what about assertions and axioms? \glec{see below}
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Homomorphic Extension}
Definition:
\begin{itemize}
\item Given morphism $m:O\to O'$,
\item define mapping from $O$-expressions $E$ to $O'$-expressions $m(E)$ by
\item replacing every $O$-symbol $s$ in $E$ \\ with the expression $s\mapsto E$ provided by $m$.
\end{itemize}

This is why morphisms must contain exactly one assignment for every $O$-symbol.
\end{frame}

\begin{frame}\frametitle{BOL Morphisms: What about Axioms?}
Definition:
\begin{itemize}
\item A morphism $m:O\to O'$ is well-formed if
\item for every axiom/assertion $F$ in $O$,
\item we have that $m(F)$ is a theorem of $O'$.
\end{itemize}

Theorem:
\begin{itemize}
\item if $\vdash_O E:E'$ then $\vdash_{O'} m(E):m(E')$
\item if $\vdash_O F$ then $\vdash_{O'} m(F)$
\end{itemize}
 \lec{morphisms preserve truth}

Mapping axioms works best if
\begin{itemize}
\item every axiom/assertion has a name
\item new expression kind for proofs \glec{given by derivations of some absolute deductive semantics}
 \glec{axioms = proof symbols = atomic proofs}
\item morphisms contain assignments $a\mapsto P$ of axiom $a$ to proof $P$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Exercise 12}
Extend your implementation of BOL with vocabulary morphisms.
This should include a function that computes the homomorphic extension.

Apply it to a test morphism.
\end{frame}

\begin{frame}\frametitle{Prevalence of Morphisms}
Deduction
\begin{itemize}
\item algebraic hierarchy, e.g., $Monoid\to Group$
\item theory $\to$ model, e.g., $Group\to Integer$
\end{itemize}
Computation
\begin{itemize}
\item class extension
\item interface implementation
\item type class instances
\item functor
\item API adapters
\end{itemize}
Concrete data
\begin{itemize}
\item between tables: database views
\item between schemas: database migration
\end{itemize}

General: module systems for building large vocabularies
\end{frame}


\begin{frame}\frametitle{Example: SFOL Morphisms}
Morphisms can be defined in the same way for every language.

In an SFOL morphism $m:V\to W$, we assign as follows:
\begin{itemize}
\item type symbols $\kw{type}\, y$ to type expressions $Y$
\item function symbols $\kw{fun}\, f:Y_1 \ldots Y_n \to Y$ to term expressions of type $m(Y)$ with input types $m(Y_1)\ldots m(Y_n)$
\item predicate symbols $\kw{pred}\, p\sq Y_1 \ldots Y_n$ to formula expressions with input types $m(Y_1)\ldots m(Y_n)$
\item axioms stating $F$ to proofs of $m(F)$
\end{itemize}

One subtle issue:
\begin{itemize}
\item Problem: SFOL has function/predicate symbols with inputs but no term/formula expressions with inputs
\item Solution: context represents inputs:
\begin{itemize}
\item $f\mapsto [\Gamma] T$ where $\Gamma\vdash_{W} T:m(Y)$
\item $p\mapsto [\Gamma] F$ where $\Gamma\vdash_{W} F:Formula$
\end{itemize}
where $\Gamma=x_1:m(Y_1),\;\ldots\;x_n:m(Y_n)$
\end{itemize}
\end{frame}